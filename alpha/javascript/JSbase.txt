js运行环境
	1. 浏览器自带js运行解释器
	2. 服务器端  nodejs 下的js解释器
		网站 https://nodejs.org/en/
		（个人安装目录）
		C:\Program Files\nodejs\

js 执行文件(以.js后缀的文件)
	1. 浏览器运行   js文件不能直接在浏览器运行，需要借助html文件

      在HTML文档中引入JS代码，有三种方式
        1.通过元素绑定事件的方式引入JS代码
          语法:
            <元素 事件函数名="JS代码语句">
                事件函数:
                    鼠标单击事件 onclick
            JS代码：
                弹框显示信息 alert('文本');
                控制台输出信息 console.log('文本');
        2.通过脚本标签<script></script>书写JS代码，标签内容为JS代码，
                可以在任意位置书写任意多次。
                注意: 浏览器遵循从上到下执行代码，书写位置可能会影响效果
            JS代码语句:
                1.prompt('');带有输入框的弹框，可用来接收用户输入
                2.document.write(''); 在网页中写入内容
                使用: 
                    1.普通的书写方式，按照从上到下的执行顺序，依次在
                    网页的相应位置插入内容，可以识别标签
                    2.如果以元素绑定事件的方式，在页面中写入内容，相当于重写页面

        3.外部的JS文件
            1.创建外部的.js文件
            2.在HTML文档中使用<script src="url"></script>引入
            3.如果<script></script>做外部文件的引入操作，标签内部就不能再写JS代码
		        <script src="01.js"></script>

	2. 后端执行(终端)
		>node 01.js

JS基础语法规则
    1.JS代码是由语句组成的，每条语句以分号“ ; ” 为结束的标志,结束分号可加可不加;
    2.JS严格区分大小写，标点符号一律采用英文的标点
    3.JS中使用   //表示单行注释   /*  */表示多行注释

    基本类型值 primitive type，比如Undefined,Null,Boolean,Number,String。
    引用类型值，也就是对象类型 Object type,比如Object,Array,Function,Date等。



JS变量与常量
    1.变量
        1.指在程序运行过程中可以随时修改的数据
        2.语法:
           1. var 变量名;     //使用关键字var声明变量
              变量 = 值;      //为变量赋值
           2. var 变量名=值;
           3. var 变量名1=值1,变量名2=值2,...;
        3.使用:
            1.var 关键字可以省略，但是一般不省略，关系到变量的作用域
            2.变量如果只使用var关键字，不赋值，默认为undefind
            3.如果变量未使用var声明，也不赋值，会报错
        4.变量的命名规范
            1.由数字，字母，下划线，$组成，不能以数字开头
            2.变量名尽量见名知意，禁止与JS的保留字和关键字冲突
                如: var function while for in each switch case
                break default continue class name new Number
                String Array db if else...
            3.如果变量名由多个单词组成，采用小驼峰标识
                eg: nameClass
    2.常量
        1.常量一经定义就不能更改，强制修改会报错
        2.语法: 
            const 常量名 = 值;
            常量在定义时，必须声明并赋值
        3.使用:
            常量名采用全大写字母，与变量名区分

        const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。
                // 创建常量对象
                const car = {type:"Fiat", model:"500", color:"white"};
                // 修改属性:
                car.color = "red";
                // 添加属性
                car.owner = "Johnson";

            但是我们不能对常量对象重新赋值：
                实例
                const car = {type:"Fiat", model:"500", color:"white"};
                car = {type:"Volvo", model:"EX60", color:"red"};    // 错误

    const定义常量与使用let 定义的变量相似：
            二者都是块级作用域
            都不能和它所在作用域内的其他变量或函数拥有相同的名称
            两者还有以下两点区别：

            const声明的常量必须初始化，而let声明的变量不用
            const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改。


    3.小数位的操作
        小数在计算机中存储或是计算都存在误差，不准确，可以设置小数的显示位数
    方法:   float.toFixed(n)    n 表示保留的小数位数    返回字符串
            eg:
                var n= 62.8834534;
                str = n.toFixed(3)



JS 基础数据类型
    1.Number 数值类型   整数和小数都是Number类型
            1.整数
                1.十进制表示方法
                    var n = 100;
                2.八进制表示整数  以 0 为前缀
                    var n = 015;
                3.十六进制 以 0x 位前缀
                    var n = 0xff
            注意: 如果使用 console.log 输出整数值，不管是什么进制表示，都转换为十进制输出

        进制转换方法    
                Number.toString(base=10); 进制转换方法,可以取 2,8,10,16，默认10 返回字符串

            2.小数
                1.直接以小数点表示小数
                    var f1 =10.5;
                2.科学计数法
                    var f2 = 1.5e3;     

    2.String 字符串类型
        1.所有使用''或者""引起来的内容，都是字符串
        2.字符串中的所有字符都是以Unicode码存储的
          字母和数值的Unicode码值与ASCII码值一致，
          中文字符的Unicode编码，在计算机中以16进制存储
        3.查看指定的字符的Unicode码值,只能查看一个，多个字符默认第一个
            方法 : String.charCodeAt([index])
            index 表示指定字符的下标，字符串中默认从0开始

        4.Unicode码中中文的范围(极少数不处于其中)
            "\u4e00" ~ "\u9fa5"
        5.转义字符
            \u  把数值转义为Unicode字符
            \n
            \t
            \'
            \\
    3.Boolean 布尔类型
        两个值  true =1 / false =0

    4.undefined
        当变量声明未定义，默认值为undefined类型
        访问对象不存在的属性时，默认值为undefined
        var a;
        console.log(a===undefined);//true
    
    5. null类型
        null 对象
            用于释放引用类型，只有一个值 null
            空类型,取 0 、''...
    
检测数据类型
    使用 typeof  可以加括号也可以不加   返回字符串
        eg:
            typeof num;
            typeof (num + str);

数据类型转换
    1.自动类型装转换(隐式)
        1.不同数据类型的数据在做运算时，会自动转换
        2. + 运算:
            1.字符串与其它数据类型做 +  运算
                一旦 + 与字符串结合使用，就会成为字符串拼接，
                其它类型自动转换为String,最终结果都为String
                'aa'+ true = 'aatrue'
                'aa' + undefined = 'aaundefined'
            
            2.Number + Boolean  = Number
                会将boolean类型自动转换为Number类型，结果为Number

              Number + undefined = NaN 
              Number + null = Number
            
            3.Boolean + undefined = NaN
              Boolean + null = 0/1

        3. -  /  * 运算：
            会把两端的数据转换为数值类型再运算
            如果有无法转换时，结果一律返回 NaN(Not a Number)
            NaN 为 Number类型

    2.强制类型转换
        1.将数值类型或布尔类型转为字符串类型
            1.  String(var)
            2. 方法: var.toString(base=10);
                var 不能为 null 和 undefined  报错
                true.toString() // '1'
        
        2.将任意类型转换为Number类型
            方法 :  Number(var)
            返回结果:
                1.数字字符串--》 Number
                2.非数字字符串 --》 失败 返回NaN
                3.布尔类型--》1/0
                4.undefined --》失败  返回NaN
                5.unll --》 0

    3.数值解析函数
        方法 : 
            parseInt(var) :  整数解析方法，解析字符串中的整数部分, 向下取整 parseInt(15.9) // 15
            parseFloat(var) : 解析字符串中的Nunber
        参数 :
            如果传递的 var 为非字符串类型，方法会先将参数转换为String,再进行解析
            parseInt(1.2) // 1
            parseInt(true) // NaN

        注意 : 
            解析时，从第一个字符开始向后解析，对每一位进行转Uniber的操作
            碰到非数字，停止解析，返回结果
                '100a'  //100
                'a100'  // NaN
        
JS中的运算符
    1.赋值运算符
        = : 将右边表达式的值赋值给左边的变量
    
    2.算术运算符
        +  -   *  /(除)   %(取余)  **(幂运算)

        1.字符串使用 + ,表示字符串拼接
        2.在其他的运算符中，会将非数字用Number()转换为Number类型参与运算
            console/log('aa'*2)// NaN
        3.NaN 与任意类型结合运算，结果都为NaN
        4. + 与 - 还表示数值的正负, +号可以省略，数值为负时 -号不可省略

    3.复合赋值算术运算符
        +=  -=   *=   /=   %=

    4.自增和自减运算
        ++  :  每执行一次作减 1 操作 
        --  :  每执行一次做减 1 操作

        做前缀与做后缀的执行顺序不同，前缀先执行后赋值，后缀先赋值后执行。

    5. 关系运算符(比较)
        运算符  >  <  >=   <=  ==(相等)  !=(不相等)  ===(恒等)  !==(不恒等)

        使用:
            关系运算符用来判断表达式之间的关系，判断结果为布尔值，返回结果

       1. 不同类型比较会用Number()自动转换为Number类型，注意Number()转换特点。
       2. 字符串之间的比较会根据每位字符串的Unicode码值进行比较，如果当前码值相同，比较下一位。
       3. undefined 为NaN ,与任何数据类型比较都返回 false


       相等与恒等
            相等: 判断两个操作数值是否相等，包含自动类型转换
            恒等: 判断操作数是否恒等，要求数据类型保持一致，值相等,不会进行数据类型转换

        不等与恒等
            不等: 值不相等，返回true
            不恒等 : 值或数据类型只要有一个不同就返回 true
        
    6.逻辑运算符
        逻辑与: &&     逻辑或: ||     逻辑非: !
            1.逻辑与: 表达式1 && 表达式2    返回逻辑短路表达式结果
            2.逻辑或: 表达式1 || 表达式2    返回逻辑短路表达式结果
            3.逻辑非：!表达式    对其后表达式的boolean值取反,返回布尔值
        
        注意：
            逻辑短路: &&  当第一个表达式为false时,就不再执行第二个表达式,返回第一个表达式执行结果
                         当第一个表达式为true时,再执行第二个表达式,返回第二个表达式执行结果
                     ||  当第一个表达式为true时，就不再执行第二个表达式,返回第一个表达式执行结果
                         当第一个表达式为false时,再执行第二个表达式,返回第二个表达式执行结果

        使用: 逻辑运算符主要用来结合条件表达式，返回结果是逻辑短路表达式结果
            1.  var a=15
                var b = a>10 && 'aaaaa';
                console.log(b); //'aaaaa'

            2. var b = 100 && console.log('aaaa'); //'aaaa'
               console.log(b); //undefined

        
    7.位运算符
        按位与 :   &  同1为1 
        按位或 :   |  有1为1    
        按位异或 : ^  不同为1  
        按位左移 : <<   // 7<<2 = 28    在7的二进制后添加0
        按位右移 : >>   // 7>>2 = 1     在7的二进制后删除

        使用:
            对数据的二进制中的每一位进行操作
        
               110101 
            >> 100000 + 10000 + 100 + 1 
            >> 2**5 + 2**4 + 2**2 + 2**0
            >> 32 + 16 + 4 + 1
            >> 53

    
    8.三目运算符(三元运算符)
        根据操作数的个数划分运算符
        语法:
            表达式1 ? 表达式2 : 表达式3;
        执行 :
            1.执行表达式1，根据其结果的boolean值(true/false)
            2.true : 返回并执行表达式2
            3.false : 返回并执行表达式3

浏览器函数   
    1. alert('警示框');
    2. var input = prompt('输入框');
        typeof(input) // String

JS中的的流程控制
    1.流程控制主要用来控制代码的执行顺序
    2.流程控制结构
        1.顺序结构
            代码自上而下顺序执行
        2.分支(选择)结构
            选择某段代码执行
        3.循环结构
            重复执行某一段代码

分支(选择)结构    
    if 语句
        1. 语法一:
            if(条件表达式)
            {
                语句块;
            }
            使用:
                1.{} 可以省略，省略之后，if语句只控制后面的第一条代码语句
                2.非零数据都为真，零为假
            
        2.语法二:
            if(条件)
            {
                语句块;
            }
            else{
                默认执行语句块;
            }

            ---------------------------
            if(条件1)
            {
                语句块;
            }
            else if(条件2)
            {
                语句块;
            }
            ......
            else if(条件n)
            {
                语句块;
            }
            else
            {
                默认执行语句块;
            }
    
    
    switch 语句
        主要用来做值匹配，值恒等时，执行某那段代码
        语法:

            switch(变量)
            {
                case 1: 
                    语句块1;
                    break;
                case 2: 
                    语句块2;
                    break;
                case 3: 
                    语句块3;
                    break;
                case 4:
                    语句块4;
                    break;
                    ......
                case n:
                    语句块n;
                    break;
                default:
                    默认执行语句块;
                    break;
            }
        使用：
            1.switch 判断值，用的是恒等，要求数据类型和值都相等才能匹配成功
            2.case 用来列出所有可能的值，一旦与变量匹配恒等，就执行当前case中的语句。
            3.default 表示匹配失败之后执行的操作，写在末尾。
            4.break 表示跳出匹配，不再向后执行。
                可以省略，省略之后，表示从当前匹配到的case向后执行所有的代码语句，不再case匹配，直到遇到break或switch结束。
            5.case 可以共用代码语句，列出所有相关的情形，共用一组执行语句：
                    case 1:
                    case 2:
                    ...
                        语句块;
                        break;
    
    比较 :
        相同点: 两者都可以用于多项分支语句
        不同点: if-else if-else可以判断各种表达式,使用范围广泛
                switch 只能用于全等判断，结构更加清晰，多条分支结构效率比 if 语句高。


循环结构
    1.循环三要素
        循环变量;
        循环条件;
        循环体;
    2.分类
        1.while 循环
            1.语法:
                while(循环条件)
                {
                    循环体;
                    循环变量;
                }
            2.流程
                1.定义循环变量
                2.判断循环条件
                3.条件成立，成立循环体
                4.改变循环变量(循环结束的条件)

        2.do - while 循环
            1.语法
                do{
                    循环体;
                    循环变量;
                }while(循环条件);
            2.流程
                1.定义循环变量;
                2.执行循环体，更新循环变量;
                3.判断循环条件，条件成立，执行循环体;
        
        while 与do-while 区别
            1.while 循环首先判断循环条件是否成立，不成立不执行循环体
            2.do-while 循环先执行循环体，再判断循环条件，决定是否执行下次循环。

        3.  for 循环
            1.语法
                for(初始化循环变量;定义循环条件;循环变量)
                {
                    循环体;
                }
            2.流程
                1.初始化循环变量
                2.判断循环条件
                3.循环首先判断循环条件是否成立
                4.更新循环变量，执行循环体
            
            变体:   for后面三个表达式可以不写或引用其他变量，但必须占位for(;;)
                1.  var i=1;
                    for(;i<=10;i++){
                        console.log(i);
                    }
                2.  var i=1;
                    for(;;i++){
                        console.log(i);
                    }
                 // 无限循环
                3.  var i=1;
                    for(;i<=10;){
                        console.log(i);
                        i++;
                    }
                4.  for(var i=1,j=5; i<=5; i++,j-=2){
                        console.log(i+','+j);
                    }
                    //  1,5
                        2,3
                        3,1
                        4,-1
                        5,-3
                5.  for(var i=1,j=5; i<=5,j>=0; i++,j-=2){
                        console.log(i+','+j);
                    }
                    //  1,5
                        2,3
                        3,1

                    循环条件有多个时，以最后一个条件为准, 逗号运算符返回最后一个表达式的值


            3. for循环与while循环比较
                1.for 循环与 while 循环执行流程相同，书写语法不同
                2.for 循环更常见于确定循环次数的场合
                  while 循环更适用于不确定循环次数的场合
                
    循环控制
        1. break  表示结束本层循环，不管还有多少次
        2. continue  表示跳出本次循环，开始下次循环

    循环嵌套
        在循环体中嵌套其它的循环
        

函数
    1.函数就是待执行的代码段
        作用
        1.封装代码段，实现某个功能
        2.代码的复用

    2.使用:
        函数的声明
        函数的调用
    3.语法:
        function 函数名(参数列表){
            函数体;
            return 返回值;
        }
        解释:
            1.js 中使用function关键字声明函数
            2.函数名自定义，命名规范参考变量的命名规范
            3.函数体就是代码段，在函数调用时执行
            4.return 表示返回值，用来返回给外界函数执行的结果，只能有一个值. 
                不写 return语句或return 空 默认返回 undefined


    4. 传参    
            参数列表表示函数体执行所需要使用的数据，可以省略，小括号不能省
            JS 中允许形参和实参个数不匹配
            实参少传，会按位置传参，无实参的形参值为 undefined
            实参多传，会按位置传参，多的实参丢弃
            所有函数的参数都是按值传递的(基本类型复制值，引用类型复制指针值(浅拷贝))
        1.  var obj1 = {
            name : "111"
            };
            var obj2 = obj1;
            console.log(obj2.name); //111
            obj2.name = "222";
            console.log(obj1.name); //222
        2.var person  = {
                name : "Tom"
            };
            function obj(peo){
                peo.name = "Jerry";
                return peo;
            }
            var result = obj(person);
            console.log(result.name);// Jerry
            console.log(person.name);// Jerry
        3.var person = {
                name : "Tom"
            }; 
            function obj(peo){
                peo = {
                name : "Jerry"
                };
                return peo;
            }
            var result = obj(person);
            console.log(result.name);// Jerry
            console.log(person.name);// Tom
    
    
    5. 匿名函数(函数表达式)
        1.  var func = function (){
                函数体;
            };
            func();
            定义变量保存函数地址，等同于函数名

        2.  var func = (function (arg){函数体;});

    函数声明和函数表达式的区别
            1. 函数表达式不存在函数声明提升，只有变量声明提升
            2. 函数表达式只能先创建在调用，函数声明可以先调用再声明    
            
    6. 匿名函数自调用 : 防止全局变量污染
            (function (arg){函数体;})();
       

    7. 函数内部对象 arguments
        arguments对象是伴随函数调用自动生成的对象，以数组结构接收函数调用的实参，
                只能在函数内部使用
        eg: 
            function f1(a){
                document.write(a,'<br>');  //100
                document.write(arguments[0],arguments[1]);  //100 200
            }
            f1(100,200);

    8. 回调函数
        把匿名函数以实参的形式传递给函数，此时匿名函数叫回调函数
        eg:     
                function fun(f){
                    f();
                }
                fun(function (){
                    console.log('hello');
                    return 1;
                });

    9. 系统函数(内置函数) js提供
        1. 中文编码和解码
            str = encodeURI('中文')
            str = decodeURI(str)
        2. isNaN(var)  检查一个数据是否为NaN, 返回 boolean
        3. parseInt(var)    转换数据为整数
           parseFloat(var)  转换数据为浮点型
        4. isFinite(var)    检查一个数值是否为有限值，返回 boolean
            eg: isFinite(1/0);  //false     1/0  IsFinity 无穷值
        5. eval('可执行表达式')   执行字符串中的表达式，相当于命令行
            eg :
                eval('function fun(){console.log("aaa");}');
                fun(); // aaa
        
    

变量的作用域
    1.变量的名字空间
    2.分类:
        1.全局变量
            在程序的任意地方都可以访问，可以在函数内部访问

        2.局部变量
            在函数内部 var 声明的变量，只能在函数内部访问,外界不能访问(形参为函数内声明变量)
            省略关键字 var 定义的变量为全局变量，函数外也能访问
        

    3. 变量声明提升
        js  解释器会在解释代码之前把当前作用域的 var关键字声明的变量提升到当前作用域的最前面,
            赋值操作还是在原位置，没有用 var关键字声明的变量不提升变量声明
       ex:
            console.log(a); // undefined
            var a = 1;
            console.log(b); //报错
            b=1;

    4. 作用域链:
            访问变量时，会首先在当前作用域中查找，没有会逐级向外链式查找
        1.    var a = 100;
                function f2(){
                    document.write(a);
                    var a =1000;//变量声明提升,赋值不提升
                }
                f2();  // undefine

        2.    var a = 1;
                function f(){
                    var a=a+3;
                    console.log(a);
                }
                f();//NaN
                console.log(a); //1

    5. 函数变量作用域
        全局创建的函数可以全局任意位置调用，局部创建的函数只能在局部作用域调用 

        函数的声明会被提升到当前作用域最前面,可以先调用再声明
        f(); // 1
        function f(){
            console.log(1);
        }
    
    6. 函数声明提升和变量声明提升(同作用域为前提)
        1. 函数声明优先提升，变量声明后提升
        2. 后提升的同名变量会覆盖前面提升的变量

        ** 当同一作用域出现同名的变量声明和函数声明时，变量会覆盖函数声明,不论是否有var关键字声明 



JS 中的对象  
    对象 : 1. 是一种引用类型的数据，存储在堆内存中
           2. 是一组属性和一组方法的集合
           3. 是一个具体的实例

    对象属性名必须是基本数据类型，Number String undefined unll boolean
        var a = {undefined:'123',unll:'123',turn:123,123:123,'aaa':'aaa'}
    对象的属性不能同名，普通属性名会覆盖同名方法名，后面定义的会覆盖前面定义的
    对象的属性值可以是任意类型  基本类型，引用类型(函数，对象等)

    object.prototype 属性使您有能力向对象添加属性和方法。

        语法
            object.prototype.name=value
        实例
            在本例中，我们将展示如何使用 prototype 属性来向对象添加属性：

            <script type="text/javascript">
            function employee(name,job,born)
            {
            this.name=name;
            this.job=job;
            this.born=born;
            }
            var bill=new employee("Bill Gates","Engineer",1985);
            employee.prototype.salary=null;
            bill.salary=20000;
            document.write(bill.salary);
            </script>
            输出：20000

    object.constructor 属性返回对创建此对象的构造函数的引用
        实例
            在本例中，我们将展示如何使用 constructor 属性：

            <script type="text/javascript">

            var test=new Boolean();

            if (test.constructor==Array)
            {
            document.write("This is an Array");
            }
            if (test.constructor==Boolean)
            {
            document.write("This is a Boolean");
            }
            if (test.constructor==Date)
            {
            document.write("This is a Date");
            }
            if (test.constructor==String)
            {
            document.write("This is a String");
            }
            </script>
    


    内置对象(通用):
       Object Array  String  Number  RegExp   Math  Date...

    宿主对象：根据不同的执行环境限制使用
        BOM : 浏览器对象
        DOM : 必须在浏览器环境下使用
        
    自定义对象
        1. 对象字面量(直接量)
        2. 内置构造函数
            1. 使用 new 关键字加构造方法才能创建对象
            2. 不加 new 关键字构造方法是类型转换函数
        3. 自定义构造函数

使用字面量创建对象
        var phone = {}; //创建空对象
        var phone1 = {
                color:'red',
                brand:'apple',
                size:5.7,
                'mian-in':'china'
                'a b':333
                };
        ** 属性名的引号可加可不加，有特殊字符必须加引号

使用内置构造函数    Object()
        var book = new Object();  //{}
        console.log(book.id); //undefined
        book.id = 100; 
        console.log(book); //{id:100}
        book.id = 'aaaa'; 
        console.log(book); //{id:aaaa}  已有属性会重新赋值
        book['title'] = '标题'; 
        console.log(book); //{id:'aaaa',title:'标题'}

        ** 构造函数调用要使用 new 关键字
           点成员访问符访问属性时不能加引号
           [‘var’] 访问属性时必须加引号,不然会在当前作用域寻找该变量的值
           对象.属性 等同 对象['属性']


    复制对象
        var newObject = new 构造方法(oldObject);
        对象为引用类型，此方法能解决两个引用访问同一对象问题


属性访问
    1. 对象.属性名
    2. 对象['属性名']
    3. 遍历对象属性
        语法 :  
            for(var key in 对象){
                var value = 对象[key]; // 不能使用对象.key和对象['key']，会去访问叫key的属性
            }
        ** 预定义属性无法遍历(预定义属性为js默认为每一个对象添加的)
    
检测属性
    1. in 关键字    是否在其中 返回boolean
      eg:
        var a = {123:'123','key':'value'}
        console.log(123 in a);  //true
        console.log('key' in a);  //true
    
    2. 对象.hasOwnProperty('属性') 返回 boolean

    3. 对象.属性 === undefined  返回 boolean

    4. 对象['属性'] === undefined  返回 boolean

对象中的方法(指向函数的属性)
        var per = {
                color:'red',
                brand:'apple',
                size:5.7,
                sky : function (){console.log(per.color + this.brand);}
                };

        per.sky();

this 关键字
    面向对象语言中 this 表示当前对象的一个引用。

    但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。
        在方法中，this 表示该方法所属的对象。
        如果单独使用，this 表示全局对象。
        在函数中，this 表示全局对象。
        在函数中，在严格模式下，this 是未定义的(undefined)。
        在事件中，this 表示接收事件的元素。
        类似 call() 和 apply() 方法可以将 this 引用到任何对象。


Array  数组

    1.数组是一种存储结构，可以存储一组数据，自动为每个元素分配下标，默认从0开始
        JS的数组为异质数据类型,元素可以是任意类型
        var arr = new Array(10);
        arr[0]={123:123}
        arr[1]=function (){console.log(11111111);}
        console.log(arr);
    
    2. 数组的分类
        1. 索引数组
        2. 关联数组
            以字符串为下标的数组
                1. 必须先创建一个空数组
                   var arr = new Array()
                2. 以 arr['id']=1 的方式赋值
                    ['id':1]
                3. 取值 : arr.id  |  arr['id']  //不能以索引取关联元素 undefined
                   赋值 ：arr.id=1111   |   arr['id']=88888     //不能以下标赋值
                
                4. 关联数组可以与索引数组同时存在,索引数组元素始终在关联数组元素之前
                    索引操作对应索引数组元素，关联操作对应关联数组元素,两者的增删改查互不相关，不会相互影响
                    

            eg:
                var arr = new Array();
                arr['id']=1;
                console.log(arr);   // ['id':1]
                console.log(arr.id);    //1
                console.log(arr['id']); //1
                arr[0]=1111;    
                console.log(arr);   // [1111,'id':1]
                arr[0]=8888;
                console.log(arr);  //[88888, id: 1]
                arr[1]=8888;
                console.log(arr);  //[88888,88888, id: 1]



    2.语法
        1. 字面量方式
            var arr = [10,'20',true];

        2. 使用Array()内置构造方法创建,同时初始化
            1. var arr = new Array();  // [empty]

            2. var arr = new Array(10,20,30);  //[10,20,30]
        
            3. 使用 new 关键字创建数组，只传一个number值时，表示指定数组长度。 
                var arr = new Array(10);   // (10) [empty × 10]
                arr.length=10
            
    
    3.使用
        1. 数组元素的下标
           默认为每个元素自动分配下标，取值范围 0 ~ length-1
           Array[index]

           取值 ： arr[index]
           赋值 ： arr[index] = value

        2.length 属性 获取数组中元素个数，最大索引数组下标加 1, 不计算关联数组元素
                    var arr = new Array();
                    arr['id']=1;   
                    arr['name']='wei';
                    console.log(arr.length);    // 0
                    arr[0]=111;
                    arr[3]=3333;
                    console.log(arr.length);    // 4
        
        3.JS 中数组长度是可以动态修改的，可以向数组任意一个位置插入元素，影响最终长度
            1. 对已有下标赋值，改变原始值为新值
            2. 对不存在的下标赋值，js会在数组中指定的下标位置创建值，已有下标和新建下标之间的元素为空，长度为新建下标加 1
                eg: 
                    var arr = [1,2,3]
                    arr[5] = 100;
                    console.log(arr)    // [1,2,3,<empty>,<empty>,100]
                    console.log(arr.length) // 6
            3. 在数组的末尾添加元素，可以使用arr.length动态添加
                arr[arr.length]=value
        
        4.遍历数组
            借助循环访问数组中每个元素

            1. 普通 for 循环 , 只能遍历索引数组
                    for(var i=0;1<arr.length;i++){
                        consoles.log(arr[i]);
                    }

            2. for in 获取元素下标,可以遍历索引数组和关联数组
                语法:
                    for(var key in arr){
                        key 为数组下标
                    }
                eg :
                    var arr = new Array();
                    arr['id']=1;   
                    arr['name']='wei';
                    arr[0]=111;
                    arr[3]=3333;
                    console.log(arr);   //  (4) [111, empty × 2, 3333, id: 1, name: "wei"]
                    for(var key in arr){
                        console.log(key);
                    } 
                    //  0
                    //  3
                    //  id
                    //  name

            3. forEach()  方法可以遍历数组获取元素和下标，只能遍历索引数组
                    arr.forEach(function(element,index){
                        console.log(element,index);
                    });
                    // 111  0
                    // 3333 3
            
        5.数组方法  忽略关联数组元素
            1.toString();
                将数组元素转换成字符串(包含句号)，返回字符串
                var s = arr.toString();
                console.log(arr.toString());    //(4) [111, empty × 2, 3333, id: 1, name: "wei"]
                                                  111,,,3333

            2.join();
                将数组中元素拼接成一个字符串，
                参数: 可选，表示拼接分隔字符,默认为‘,’
                返回值: 拼接后的字符串
                var s1 = arr.join("#");
                //(4) [111, empty × 2, 3333, id: 1, name: "wei"]
                //111###3333
            
            3.reverse()
                var a = arr.reverse()
                翻转数组元素，以倒序形式在原始数组地址上重新排列数组元素
                返回值:为翻转后的数组 (原始数组也改变)
            
            4.sort()
                对数组中元素排序，默认按元素的Unicode码值升序排列
                返回值: 排序后的数组 (原始数组也改变)
                参数: 可选，可以是自定义的排序函数
                    arr.sort(function (a,b){   // a 表示第一个数，b为第二个是
                        return a-b;     // a-b表示数字比较升序,b-a为降序
                    }) 

            5. concat(arr1,arr2,...) 
                拼接两个或者更多的数组
                返回值 ：拼接后的新数组，不改变原始数组
                arr.concat(arr1,arr2);
                eg :
                    var arr=[1,2,3,4,5],arr1 = [6,7,8,9];
                    var a = arr.concat(arr1)
                    console.log(a);
                    console.log(arr);
                    console.log(arr1);
                    //[1, 2, 3, 4, 5, 6, 7, 8, 9]
                    //[1,2,3,4,5]
                    //[6,7,8,9]
            
            6. slice(start,end)  数组切片    [包含start,不包含end)
                参数 : 一个或两个数值
                返回值 : 截取的数组
                var a = arr.slice(index)    截取从 index 到最后
                var a = arr.slice(index1,index2)    截取从 index1 到 index2
                var a = arr.slice(-index)      从倒数第index到最后
                var a = arr.slice(-index1,-index2)      从倒数第index1到倒数第index2

                start 超过数组下标时 返回 []
            
            7. splice(start: number[, deleteCount?: number][,replace1,replace2...])  
                    在指定下标处删除或插入一个或多个元素（删除包含下标元素，插入在下标元素之后插入）
                参数 ： start  元素下标,可以为负数,-1 为倒数第一个
                        deleteCount  删除的个数(缺省默认删除到最后，为0表示不删除,只插入元素)
                        replace  在下标处插入元素,可以有多个元素(缺省不插入元素)
                返回值 : 删除的元素组成的数组,不删除元素为[],改变原始数组
            eg:
                1. var arr =[1,2,3,4,5,6,7,8,9];
                  var b =arr.splice(1,1)
                  console.log(b);     // [2]
                  console.log(arr);   //  [1, 3, 4, 5, 6, 7, 8, 9]

                2.var b =arr.splice(1,0,'aaa','bbb')
                  console.log(b);   //[]
                  console.log(arr); //[1, "aaa","bbb", 2, 3, 4, 5, 6, 7, 8, 9]

                3. var b =arr.splice(1,0,[10,23])
                   // [1, [10,23], 2, 3, 4, 5, 6, 7, 8, 9]

    5.数组的进出栈操作
        栈与队列都是存储结构
        特点:
            栈: 只有一个出入口，数据按顺序存入，先进后出
            队列: 先进先出
        数组采用栈结构存储

        方法介绍:
            1.操作数组尾部元素
                1.push(data)
                  在数组的末尾添加元素，多个元素之间使用逗号隔开
                  返回值 : 新数组的长度
                  注意 : 直接向数组添加元素，原始数组会被改变
                
                2.pop(data)
                  移除数组末尾元素
                  返回值: 移除的数组元素
                  注意: 原始数组会被改变

            2.操作数组的头部元素
                1.在数组的头部追加元素
                    unshift();
                     参数: 一个或多个元素
                     返回值 : 数组长度
                2.移除数组头部元素
                    shift();
                     返回值: 被移除的元素

    二维数组
        数组中每个元素都是数组
            Array[[],[],[]]
        访问:
            Array[index][index];

包装对象
    目的 ：让原始数据类型也和引用数据类型一样，有属性和方法

    JS提供三种包装类型
        String  Number  Boolean


字符串  String
    创建语法：
        1. 字面量 var str1 ="";
        2. 内置构造方法 var str2 = new String("");
    
    转义字符    \
        \n  换行
        \t  制表符
        \r  返回行首
    转为普通字符
        \'  'It\'s a apple'
        \"  "It\"s a apple"
        \\ 
        \%

    属性和方法
        1.属性
            str.length : 获取字符串长度(字符个数)

        2.遍历字符串
            由于字符串也是类数组结构，每个字符都会分配下标，
            可以按照数组访问元素的方式访问字符
        
        3.常用方法
            1.转换大小写
                str.toUpperCase()  转换大写，返回新字符串
                str.toLowerCase()  转换小写，返回新字符串

            2.获取指定字符
                str.charAt(index)   获取指定下标位置的字符 , 返回字符

                str.fromCharCode(num) 获取任意Unicode码对应的字符
                        返回Unicode字符

                str.charCodeAt(index)  获取指定位置的Unicode码值
                        参数省略表示获取第一个字符，返回整型

            3.检索字符串
                获取指定字符的下标
                1. str.indexOf(value[,startIndex])  
                    参数为字符,可选参数为起始位置下标,向后找
                    成功返回字符第一次出现的位置下标(整型)
                    失败返回 -1 表示不存在
                
                2. str.lastIndexOf(value[,startIndex])
                    参数为字符,可选参数为起始位置下标,向前找
                    返回值 : 返回指定字符最后出现位置的下标(整型)
                    失败返回 -1 表示不存在
            
            4.截取字符串
                1. str.slice(startIndex[,endIndex]);
                    根据起始下标截取子串,省略结束下标，表示截取到末尾
                    参数: 字符下标,负数为倒序截取
                    返回值: 左闭右开子字符串[startIndex,endIndex)
                2. str.substring(startIndex[,endIndex]);
                    根据起始下标截取子串,省略结束下标，表示截取到末尾
                    参数: 字符下标,为负数转换为 0
                    返回值: 左闭右开子字符串[startIndex,endIndex)
                3. str.substr(startIndex[,count]);
                    根据起始下标开始截取指定长度的子字符串
                    参数: startIndex:字符下标,可以为负数
                          count : 截取的个数，省略，表示截取到末尾
                    返回值: 以startIndex字符为起始的count个长度字符串

            5.分割字符串    
                split() 方法用于把一个字符串分割成字符串数组。

                语法
                    stringObject.split(separator[,howmany])
                    参数
                        separator	必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。
                        howmany	    可选。该参数可指定返回的数组的最大长度。如果设置了该参数，超过长度个数的子串会丢弃。
                                    如果没有设置该参数，整个字符串都会被分割返回，不考虑它的长度。
                    返回值
                        一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。
                        返回的数组中的字串不包括 separator 自身。
                        如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。

                    提示和注释
                        注释：如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。
                        注释：String.split() 执行的操作与 Array.join 执行的操作是相反的。
            
            6.模式匹配  
                1.结合正则表达式实现查找和替换指定字符
                2.正则表达式
                    var reg1 = /\d{3,5}/;
                    var reg2 = /h/;
                  模式修饰符:
                    i : ignore case 忽略大小写
                    g : global 全局匹配,不加只匹配第一处
                eg:
                    var reg = /你好/ig;

                3.方法:
                    1.  str.match(substr|regExp)    查找子字符串
                            根据指定的字符串或正则模式，查找字符串内容,字符串或者正则模式不加g只匹配第一处
                            返回匹配结果数组
                            var arr = str.match(/a/g);

                    1.  str.replace(substr|regExp,newString)    替换字符串
                            根据指定的字符串或正则模式匹配子字符串，并用新字符串替换,字符串或者正则模式不加g只匹配第一处
                            返回替换后的字符串

                    3.  str.search(substr|regExp)   查找下标
                            检索字符串中指定的子字符串或正则模式,只匹配第一处,正则模式加g不起作用
                            返回匹配的子字符串起始位置下标,没有返回 -1
                            var n = str.search(/Runoob/i);
                    
            
正则表达式  RegExp 对象
    1.正则表达式 Regular Expression
        设置模式，匹配或验证字符串格式

    2.创建正则表达式对象
        1. 直接量语法   /pattern/attributes
            var reg = /^\d{6}$/ig;
        2. 创建 RegExp 对象的语法：new RegExp(pattern, attributes);
            var reg = new RegExp("模式","ig 修饰符");
        
        参数
          pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。

          attributes 是一个可选的字符串，包含属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
                    ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。
        
        返回值
            一个新的 RegExp 对象，具有指定的模式和标志。如果参数 pattern 是正则表达式而不是字符串，那么 RegExp() 
            构造函数将用与指定的 RegExp 相同的模式和标志创建一个新的 RegExp 对象。
            如果不用 new 运算符，而将 RegExp() 作为函数调用，那么它的行为与用 new 运算符调用时一样，只是当 pattern 是正则表达式时，
            它只返回 pattern，而不再创建一个新的 RegExp 对象。

        注意: 模式用字符串表示时元字符要多加转义\,避免转义解析。

    模式修饰符:
            i : ignore case 忽略大小写
            g : global 全局匹配,不加只匹配第一处
            m :	执行多行匹配。
    
    方括号
            方括号用于查找某个范围内的字符：

            表达式	描述
            [abc]	查找方括号之间的任何字符。
            [^abc]	查找任何不在方括号之间的字符。
            [0-9]	查找任何从 0 至 9 的数字。
            [a-z]	查找任何从小写 a 到小写 z 的字符。
            [A-Z]	查找任何从大写 A 到大写 Z 的字符。
            [A-z]	查找任何从大写 A 到小写 z 的字符。
            [adgk]	查找给定集合内的任何字符。
            [^adgk]	查找给定集合外的任何字符。
            (red|blue|green)	查找任何指定的选项。

    元字符
            元字符（Metacharacter）是拥有特殊含义的字符：

            元字符	描述
            .	查找单个字符，除了换行和行结束符。
            \w	查找单词字符。
            \W	查找非单词字符。
            \d	查找数字。
            \D	查找非数字字符。
            \s	查找空白字符。
            \S	查找非空白字符。
            \b	匹配单词边界。
            \B	匹配非单词边界。
            \0	查找 NUL 字符。
            \n	查找换行符。
            \f	查找换页符。
            \r	查找回车符。
            \t	查找制表符。
            \v	查找垂直制表符。
            \xxx	查找以八进制数 xxx 规定的字符。
            \xdd	查找以十六进制数 dd 规定的字符。
            \uxxxx	查找以十六进制数 xxxx 规定的 Unicode 字符。

    量词
            量词	描述
            n+	匹配任何包含至少一个 n 的字符串。
            n*	匹配任何包含零个或多个 n 的字符串。
            n?	匹配任何包含零个或一个 n 的字符串。
            n{X}	匹配包含 X 个 n 的序列的字符串。
            n{X,Y}	匹配包含 X 至 Y 个 n 的序列的字符串。
            n{X,}	匹配包含至少 X 个 n 的序列的字符串。
            n$	匹配任何结尾为 n 的字符串。
            ^n	匹配任何开头为 n 的字符串。
            ?=n	匹配任何其后紧接指定字符串 n 的字符串。
            ?!n	匹配任何其后没有紧接指定字符串 n 的字符串。

    RegExp 对象属性
            属性	    描述
            global	    RegExp 对象是否具有标志 g。
            ignoreCase	RegExp 对象是否具有标志 i。
            lastIndex	一个整数，标示开始下一次匹配的字符位置。
                    指定下一次匹配的起始索引，只有在设置了全局匹配才起作用
                    这是创建全局匹配正则的属性
                    原则上，同一个正则表达式不要重复使用,lastIndex每次起始索引不同，影响验证结果
                    当reg.lastIndex设置为0时，每次都从0位开始索引
            multiline	RegExp 对象是否具有标志 m。
            source	    正则表达式的源文本。

    RegExp 对象方法
            方法	    描述
            compile	编译正则表达式。
                compile() 方法用于在脚本执行过程中编译正则表达式。
                compile() 方法也可用于改变和重新编译正则表达式。

                语法
                    RegExpObject.compile(regexp,modifier)
                    参数	    描述
                    regexp	    正则表达式。
                    modifier	规定匹配的类型。"g" 用于全局匹配，"i" 用于区分大小写，"gi" 用于全局区分大小写的匹配。

                eg: 
                    var str="Every man in the world! Every woman on earth!";

                    patt=/man/g;
                    str2=str.replace(patt,"person");
                    document.write(str2+"<br />");

                    patt=/(wo)?man/g;
                    patt.compile(patt);
                    str2=str.replace(patt,"person");
                    document.write(str2);

            exec	检索字符串中指定的值。返回找到的值，并确定其位置。
                reg.exec() 方法是一个正则表达式方法。
                    用于检索字符串中的正则表达式的匹配。
                    该函数返回一个数组，其中存放匹配的结果。
                    如果未找到匹配，则返回值为 null。
                    /e/.exec("The best things in life are free!");

            test	检索字符串中指定的值。返回 true 或 false。
                reg.text(param)
                    参数: 要验证的字符串
                    返回值: ture/false 表示字符串中是否包含满足正则模式的内容
                    /e/.test("The best things in life are free!");

    支持正则表达式的 String 对象的方法
            方法	描述
            search	检索与正则表达式相匹配的值。
            match	找到一个或多个正则表达式的匹配。
            replace	替换与正则表达式匹配的子串。
            split	把字符串分割为字符串数组。

宿主对象  数学对象 Math
        不需要创建对象，直接使用

    1.属性
        数学常量:
            Math.PI : 圆周率 / 180deg
            Math.E  : 自然对数

    2.方法:
        三角函数
        Math.sin(deg)
        Math.tan()
        Math.cos()
        注意:
            参数为度数，可以使用Math.PI(180deg)进行转换
            涉及小数可能存在误差
    
    3.计算函数
        Math.sqrt(x);  对x开平方
        Math.Pow(x,y); 求x的y次方
        Math.log(x);  求对数

    4.数值函数
        Math.abs(x)  求绝对值
        Math.max(1,2,3)  求最大值
        Math.min(1,2,3)  求最小值
        Math.random()   获取[0,1)之间的随机数
        Math.ceil(x)   对x向上取整
        Math.floor(x)  对x向下取整，舍弃小数
        Math.round(x)  四舍五入
        Math.random()   获取随机数,返回 [0~1)的 16位小数
    
日期对象 Date
    1.提供获取客户端时间与日期的方法
    2.创建日期对象,nodejs下会转换为0时区时间
        1. var date1 = new Date();  获取当前系统时间

        2. 根据指定的日期时间创建对象
            var date1 = new Date("2018-11-11 10:10:10");
            var date2 = new Date("2018/11/11 10:10:10");
            var date3 = new Date(2018,10,11,10,10,10);//月份0~11,写12年加一
            var date4 = new Date(1000); //表示1000毫秒 1970-01-01 00:00:01
            
    3.方法
        1.设置或获取当前时间对象的毫秒数
            date.getTime();  获取当前日期对象距离1970-01-01 00:00:00 之间的毫秒数

            var n =new Date();
            console.log(n.getTime());
        2.date.setTime(millisec); //millisec毫秒
            把date设置为距离时间元年1970-01-01 00:00:00 millisec毫秒的日期时间
            返回值 ：参数 millisec
            eg:
                var n =new Date();
                n.setTime(100000000)
                console.log(n); //Fri Jan 02 1970 11:46:40 GMT+0800 (中国标准时间)

        3.获取时间分量
            date.getFullYear()
            获取当前日期对象中的年份信息
            返回四位年份数字

            date.getMonth()
            获取日期对象中的月份信息
            返回值0-11 对应12个月，需要+1显示

            date.getDate()
            获取日期对象中的日子信息
            返回值 : 正常的号数

            date.getDay()
            获取日期对象中的星期信息
            返回值 0-6 对应 日-六

            date.getHours()
            获取小时数

            date.getMinutes()
            获取分钟数

            date.getSeconds()
            获取秒数

            date.getMilliseconds()
            获取毫秒

        设置时间
            date.setFullYear(Year)

            parse()	返回1970年1月1日午夜到指定日期（字符串）的毫秒数。
            setDate()	设置 Date 对象中月的某一天 (1 ~ 31)。
            setMonth()	设置 Date 对象中月份 (0 ~ 11)。
            setFullYear()	设置 Date 对象中的年份（四位数字）。
            setHours()	设置 Date 对象中的小时 (0 ~ 23)。
            setMinutes()	设置 Date 对象中的分钟 (0 ~ 59)。
            setSeconds()	设置 Date 对象中的秒钟 (0 ~ 59)。
            setMilliseconds()	设置 Date 对象中的毫秒 (0 ~ 999)。


    日期转字符串格式
        date.toString()  原样转换为字符串
        date.toLocaleString() 按本地日期时间格式转换为字符串
        date.toLocaleDateString()  按本地日期格式转换为字符串
        date.toLocaleTimeString()  按本地时间格式转换为字符串

Boolean 对象
        Boolean 对象表示两个值："true" 或 "false"。

    创建 Boolean 对象的语法：
        new Boolean(value);	//构造函数
        Boolean(value);		//转换函数
        隐示转换 : !value
    参数
        参数 value 由布尔对象存放的值或者要转换成布尔值的值。

    返回值
        当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。
        如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。
        注释：如果省略 value 参数，或者设置为 0、-0、null、""、false、undefined 或 NaN，
                则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 "false"或" ",[],{}S）。

    方法 :
        bool.toString()

Number 对象
    Number 对象是原始数值的包装对象。

    创建 Number 对象的语法：
        var myNum=new Number(value);
        var myNum=Number(value);
    参数
        参数 value 是要创建的 Number 对象的数值，或是要转换成数字的值。

    返回值
        当 Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象。
        如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值，
        并且返回这个值（如果转换失败，则返回 NaN）。

    Number 对象属性
    属性	        描述
    constructor	返回对创建此对象的 Number 函数的引用。
    MAX_VALUE	可表示的最大的数。
    MIN_VALUE	可表示的最小的数。
    NaN	非数字值。
    NEGATIVE_INFINITY	负无穷大，溢出时返回该值。
    POSITIVE_INFINITY	正无穷大，溢出时返回该值。
    prototype	使您有能力向对象添加属性和方法。

    Number 对象方法
            方法	        描述
        toString	    把数字转换为字符串，使用指定的基数。
            隐式转换字符串 :   num+''或 ''+num
        toLocaleString	把数字转换为字符串，使用本地数字格式顺序。
        toFixed	        把数字转换为字符串，结果的小数点后有指定位数的数字。
        toExponential	把对象的值转换为指数计数法。
        toPrecision	    把数字格式化为指定的长度。
        valueOf	        返回一个 Number 对象的基本数字值。
    Number 对象描述
        在 JavaScript 中，数字是一种基本的数据类型。JavaScript 还支持 Number 对象，该对象是原始数值的包装对象。
        在必要时，JavaScript 会自动地在原始数据和对象之间转换。在 JavaScript 1.1 中，可以用构造函数 Number() 
        明确地创建一个 Number 对象，尽管这样做并没有什么必要。

    构造函数 Number() 可以不与运算符 new 一起使用，而直接作为转化函数来使用。以这种方式调用 Number() 时，
        它会把自己的参数转化成一个数字，然后返回转换后的原始数值（或 NaN）。

    构造函数通常还用作 5 个有用的数字常量的占位符，这 5 个有用的数字常量分别是可表示的最大数、可表示的最小数、
    正无穷大、负无穷大和特殊的 NaN 值。 注意，这些值是构造函数 Number() 自身的属性，而不是单独的某个 Number 对象的属性。

    比如这样使用属性 MAX_VALUE 是正确的：
        var big = Number.MAX_VALUE

    但是这样是错误的：
        var n= new Number(2);
        var big = n.MAX_VALUE

    作为比较，我们看一下 toString() 和 Number 对象的其他方法，它们是每个 Number 对象的方法，
    而不是 Number() 构造函数的方法。前面提到过，在必要时，JavaScript 会自动地把原始数值转化
    成 Number 对象，调用 Number 方法的既可以是 Number 对象，也可以是原始数字值。

    var n = 123;
    var binary_value = n.toString(2);


JavaScript 全局对象
    全局属性和函数可用于所有内建的 JavaScript 对象。

    全局对象描述
        全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有
        其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。

        在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。但通常不必用这种方式引用全局对象，因为全局
        对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。例如，当JavaScript 
        代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层
         JavaScript 代码中声明的所有变量都将成为全局对象的属性。

        全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。

        在 JavaScript 代码嵌入一个特殊环境中时，全局对象通常具有环境特定的属性。实际上，ECMAScript 标准没有规定
        全局对象的类型，JavaScript 的实现或嵌入的 JavaScript 都可以把任意类型的对象作为全局对象，只要该对象定义
        了这里列出的基本属性和函数。例如，在允许通过 LiveConnect 或相关的技术来脚本化 Java 的 JavaScript 实现中，
        全局对象被赋予了这里列出的 java 和 Package 属性以及 getClass() 方法。而在客户端 JavaScript 中，全局对象
        就是 Window 对象，表示允许 JavaScript 代码的 Web 浏览器窗口。

    顶层函数（全局函数）
           函数	                    描述
        decodeURI()	            解码某个编码的 URI。
        decodeURIComponent()	解码一个编码的 URI 组件。
        encodeURI()	            把字符串编码为 URI。
        encodeURIComponent()	把字符串编码为 URI 组件。
        escape()	            对字符串进行编码。
        eval()	                计算 JavaScript 字符串，并把它作为脚本代码来执行。
        getClass()	            返回一个 JavaObject 的 JavaClass。
        isFinite()	            检查某个值是否为有穷大的数。
        isNaN()	                检查某个值是否是数字。
        Number()	            把对象的值转换为数字。
        parseFloat()	        解析一个字符串并返回一个浮点数。
        parseInt()	            解析一个字符串并返回一个整数。
        String()	            把对象的值转换为字符串。
        unescape()	            对由 escape() 编码的字符串进行解码。

异常处理
        try 语句测试代码块的错误。
        catch 语句处理错误。
        throw 语句创建自定义错误。
        finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。

    语法：
        try {
            ...    //异常的抛出
        } catch(err) {
            ...    //异常的捕获与处理
        } finally {
            ...    //结束处理
        }


    抛出异常
        throw err;
        
        eg:
            x = document.getElementById("demo").value;
            try { 
                if(x == "") throw "is Empty";
                if(isNaN(x)) throw "not a number";
                if(x > 10) throw "too high";
                if(x < 5) throw "too low";
            }
            catch(err) {
                message.innerHTML = "Input " + err;
            }

ES6
    ECMA组织制定js规范
    现在的标准  ECMAScrip6

ES6新特征 
    1. 块级作用域
        在大括号内用 let关键字声明变量,只能在快内访问
        语法 :  {   
                    let a=1;    //let关键字声明块级作用域变量,不能用var
                }
        块级作用域 : {}, for, if,while,do-while,switch...

    2.箭头函数
        是回调函数的另一种写法，和匿名函数不完全一种
        (arguments)=>{
            代码块;
        }

        当代码块只有一行代码，且含有return时可以这样写
            (a,b)=>a-b
    
    3. 缺省参数
        允许为形参设置默认值
            function add(a,b=0){
                return a+b;
            }

    4. 模板字符串(格式化字符串)
        使用反引号 ` `括起字符串,使用 ${表达式}导入数据
        var str = `
                ${year}年
                ${month+1}月
                ${date<10?'0'+date:date}日
                `
        在模板字符串中的非{}中可以写任意符号，都会被解释为字符串，{}中可以写任意js语法，会被解释执行

    5. generator
        generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。
          eg:
                function* foo(x) {
                    yield x + 1;
                    yield x + 2;
                    return x + 3;
                    }
        generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。

        直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。

        调用generator对象有两个方法
            一是不断地调用generator对象的next()方法：
                    var f = fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
                    f.next(); // {value: 0, done: false}
                    f.next(); // {value: 1, done: false}
                    f.next(); // {value: 1, done: false}
                    f.next(); // {value: 2, done: false}
                    f.next(); // {value: 3, done: false}
                    f.next(); // {value: undefined, done: true}
                next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。
                返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。
                当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。

            第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：
                    for (var x of fib(10)) {
                        console.log(x); // 依次输出0, 1, 1, 2, 3, ...
                        }
