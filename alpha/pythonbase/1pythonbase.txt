python简介
  python的诞生
      创建人: Guido van Rossum (荷兰人)
      时  间: 1989年

  python语言的应用领域：
      系统运维
      网络编程(搜索引擎，爬虫，服务器编程)
      科学计算
      人工智能,机器人
      web 开发
      云计算
      大数据及数据库编程
      教育
      游戏，图像处理
      其它。。。
  优缺点:
    优点:
      面向对象(Java, C++, Python, C#, Swift)
      免费
      可移植 (Windows, Linux, Unix, IOS, 安卓)
      可混合编程(C / C++ / Java / .net )
      简单易学易用
      应用领域广泛
      开源
    缺点:
      与 C/C++相比，执行速度不够快
      不能封闭源代码

  python的官网
      https://www.python.org

  python的版本
      python V2.7 (2020年结束维护)
      python V3.5 (当前教学)
      python V3.8 (最新)

  python的解释执行器的类型
      CPython     （C语言开发)
      Jython      (Java语言开发)
      IronPython  (.net开发)
      PyPy        (Python语言开发)

  python 程序的组成:
        程序是由模块组成
        模块是由数据，函数，类等组成
        函数由语句组成
        语句由表达式组成

python 特色语法
    python 中的自动化内存管理
        a = 10000
        b = 20000
        a = a + b  # 释放10000这个对象，a重新绑定30000
        c = a   # c同时绑定在30000上
    内存管理:　　garbage collection
        1.每个对象都会记录有几个变量绑定（引用）自身，当引用的数量为0时，则此对象将被
            销毁（释放内存资源),此种自动化内存管理的方式叫引用计数

        2、在引用计数的基础上，通过标记-清除（mark and sweep）
           解决容器对象可能产生的循环引用问题
	    
        3、分代回收（generation collection）以空间换时间的方法	
	        提高垃圾回收的速度
    
    小整数对象池
        CPython中，整数-5至256的数永远存在于小整数池中，不会释放且可重复使用
        　引用它们的变量id会一致．
        示例:
            a = 100
            b = 100
            a is b # True
    
    函数式编程
     　函数式编程是指用一系列函数解决问题
        在函数式编程当中，函数是基本单位，除了匿名函数，
        python中还常使用filter,map,reduce,apply等函数来
        支持函数式编程

    　　说明：1、用每一个函数完成细小的功能，一系列函数的任何组成
          　　　　可以解决大问题(函数尽量专一，便于灵活调用)
          　　2、函数仅接受输入并产生输出，不包含任何可能影响输出
          　　　的内部状态
    　##  函数式编程应用
		　print(sum(map(lambda x:x**2,range(1,10))))
		　print(sum(map(lambda x:x**3,range(1,10))))
		　print(sum(map(pow,range(1,10),range(9,0,-1))))

    函数的可重入性：
        当一个函数没有访问除局部变量以外的变量，则此函数为可重入函数。
      (尽量写可重入函数)

      面向对象编程  object-oriented programming   思想
      
     面向过程编程基本单位：函数
     面向对象编程基本单位：类 class

    对象：
        对象是指现实中的实体或物体(实例)

    面向对象：
        把一切看成是对象(实例...)，用各种对象之间的关系来描述事物

    对象都有那些特征：
        对象有很多属性(名词，形容词)
            姓名，年龄，性别
        对象有很多行为(动作，动词)
            学习，吃饭，睡觉，踢球，工作

python两种运行模式:
  执行模式:
     python3 xxxx.py
  交互模式: 
    进入交互模式:
         $ python3 <回车>
         >>>
    退出交互模式:
        >>> quit() <回车>
        >>> exit() <回车>
        或输入: ctrl + d (输入文件结束符)
    在交互模式下查看当前作用域的所有变量
        >>> help('__main__')
        退出键: q
python文本语法
    注释：
      语法：以英文 # 开头， 直至行尾
      作用: 让注释内容不参加解释执行
    缩进：
      作用：缩进四格
      语法：复合语句表示包含关系 (if/while/for/def)
    
知识点
    1. 数据类型:
        数值类型：
            int, float, complex, bool
        容器:
            不可变的容器
            str, tuple, frozenset, bytes(字节串)
            可变的容器
            list, dict, set, bytearray(字节数组)
    2.值:
            None, False, True

    3. 运算符
        算术运算符
            + - * /  //  %  **
        比较运算符:
            < <= > >= == !=
        in / not in 
        is, is not
        布尔运算:
            not, and, or
        +(正号) -(负号)
        & | ^ 
        [] (索引,切片,键索引)
    表达式:
        1
        1 + 2
        max(1,2,3)  # 函数调用是表达式
        x if x > y else y, 条件表达式 
        三种推导式:
            三种：列表推导式[x for x in L if ....]
            字典推导式{x:x**2 for x in L if ....}
            集合推导式{x for x in L if ....}
    语句
        表达式语句:
            所有的表达式都可以单独写在一行，形成一个语句,例:
            print("hello world")
            1 + 2
        赋值语句:
            a = 100
            a = b = c = 100
            x, y = 100, 200
            a[0] = 100
            dict['name'] = 'tarena'
        del 语句
        if 语句
        while 语句
        for 语句
        break 语句
        continue语句
        pass 语句


    内建函数:

        len(x), max(x), min(x), sum(x), any(x), all(x)
        构造函数(用来创建同类型的数据对象)
            bool(x), int(x), float(x), complex(x),
            list(x), tuple(x), str(x), dict(x), set(x),
            frozenset(x)
        abs(x)
        round(x)
        pow(x, y, z=None)

        bin(x), oct(x), hex(x)
        chr(x), ord(x)
        range(start, stop, step)
        input(x), print(x)

核心数据类型

       基本(整型数int,浮点型数float，复数complex， 布尔型bool,字符，Ｎone)
       容器（字符串 str, 列表 list ,元组 tuple,字典 dict ,集合 set ,固化集合 forzenset.......
  基本类型
    整型数 int
        整数是不带有小数部分的数字

      整数 的字面值表示方式
        十进制表示方式
        如:
          10
          200
          -100
          99999999999999999999999999
        八进制表示方式   0o
          如:
            0o177  (127)
            0o11   (9)
        十六进制表示方式:      0x
          如:
            0x11  (17)
            0xFF  (255)
            0x1a2b 
        二进制表示方式:        0b
          如:
            0b111
            0b101

          进制:
              二进制 逢二进一 (0~1)
              八进制 逢八进一 (0~7)
              十进制 逢十进一 (0~9)
              十六进制 逢十六进一 (0~9,A-F, a-f)

    浮点型数 float
          浮点数是带有小数部分的数字(小数部分可以是0)

      浮点数的字面值表示方式:
        小数表示法:
             如:
                3.14  3.1  3.0  3.  0.14  .14
        
        科学计数法:
          格式:
              小数 e/E (正负号) 指数
            如:
              6.18E-1  （等同于 0.618)
              2.9979e8  等于299790000.0

    复数 complex
        分为两部分:
           实部(real)
           虚部(image)
            虚部是以j或J结尾的数

        字面值:
          1j
          (2J)
          1+2J
          3-4j

    布尔型数 bool
        用来表求真和假两种状态的数字
          True 表示值(条件满足或成立)
          False 表示假(条件不满足或不成立)
        说明:
          True 的值为1
          False 的值为0

    内置对象  特殊类型
      空值 None
        None 是一个表示不存在的特殊对象
      作用:
        用来占位
        变量解除绑定
        表示没有结果

  构造类型
        
    　容器  　　　　　　　　　
        字符串   str       # 不可变序列，只能存字符 加＂＂　　下标索引　　　　　　　　　　　以字符为元素单位
        列表     list      # 可变的序列，可以存任意数据　　　　下标索引　　可赋值         以　,　为元素单位
        元组     tuple     # 不可变序列，可以存任意数据　　　　下标索引                 以　,　为元素单位
        字典     dict      #　可变序列，key为不可变，value为可变　key索引　可赋值       以　,　为元素单位
        集合     set       #　可变无序，value为不可变，　　　　无索引　　用方法增删      以　,　为元素单位
        固定集合　frozenset #　不可变无序，同集合，无索引，　　　　                     以　,　为元素单位
        字节串   bytes     #　不可变序列，存储以字节为单位的数据　下标索引              以一字节为元素单位
        字节数组 bytearray ＃　可变序列，　同字节串，　　　　　　　下标索引　　可赋值      以一字节为元素单位 
            
        类型转换：
        　　　　list,tuple,set可以互相转换，但 set 不保证转换的顺序
        　　　 　str 不能转换为字典，报错
        　　　　任何集合都能转为str , 只有 bytes　能与　str　互转，
        　　　　字典是以键值对为元素转换的，转换集合的元素必须是键值对对象。

        　  list(dict)    --->   [key1,key2,key3,...]　　　以　key　为元素转换
            tuple(dict)  --->   (key1,key2,key3,...)
            set(dict)    --->   {key1,key2,key3,...}
        　　
        　　str(dict)    --->   "{key:value,key:value,key:value,}" 字符串是以字符为元素转换
        　　str(list)    --->   "[1,2,3,4,5]"　　list(str) --> ['[','1',',','2',',','3',..]
           str(tuple)    --->   "(1,2,3,4,5)"
           str(set)    --->     "｛1,2,3,4,5｝"

           dict(str)   报错　　str 的元素是字符，不可能分为键值对
           dict(list)   list = [1,2,3]   报错
                        list = [(1,2),(2,（３，３）)]   --->{1:2,2:(3,３）}
           dict(tuple)   同列表
           dict(set)     同列表

        
                   bytes 和 str 转换
            
                编码(encode)
            str------------>bytes
            b = s.encode(encoding='utf-8')

                编码(decode)
            bytes---------->str
            s = b.decode(decoding='utf-8')



           



        字典 VS 列表
            1. 都是可变对象
            2. 索引方式不同,列表用整数索引，字典用键索引
            3. 字典的插入，删除，修改数据的速度可能会快于列表(重要)
            4. 列表的存储是有序的，字典的存储是无序的

      序列相关的函数:
        len(x), max(x), min(x), sum(x), any(x), all(x)

      序列相关的函数:
        reversed(可迭代对象)  返回反向顺序的可迭代对象
        sorted(iterable, key=None, reverse=False) 返回已排序的列表

        示例:
            t = (4, 8, 6, 2, 7)
            L = [x for x in reversed(t)]
            # L = [7, 2, 6, 8, 4]  # 原来先后顺序的反向
            for x in reversed(t):
                print(x)  #  打印: 7  2  6  8  4

            L2 = sorted(t)  # L2 = [2, 4, 6, 7, 8]
            L3 = sorted(t, reverse=True)  # L3 = [8, 7, 6, 4, 2]

    字符串 str
      作用:  用来记录文本(文字)信息
      字符串的表示方式:
            在非注释中，凡是用引号括起来的部分都是字符串
            '    单引号
            "    双引号
            '''  三单引号
            """  三双引号
      空字符串的字面值表示方法
            ''
            ""
            ''''''
            """"""
      非空字符串的表示方法:
            'hello'
            "world"
            '''hello'''
            """world"""

        单引和双引号的区别:
            单引号内的双引号不算结束符
            双引号内的单引号不算结束符
        示例:
            print("I'm a teacher!")  # I'm a teacher
            print('I am "weimingze"')  # I am "weimingze"
        三引号字符串的作用:
            三引号字符串中的换行会自动转换为换行符
            三引号内可以包含单引号和双引号
        示例:
            s = 'welcome to beijing!\nI like python!\nI am Studing!'
            print(s)
            s2 = '''welcome to beijing!
            I like python!
            I am Studing!'''
            print(s2)

        隐式字符串字面值拼接
            s = "I'm a teacher!"  'My name is "weimingze"'

        用转义序列代表特殊字符
            字符串字面值中，用字符反斜杠(\)后跟一些字符代表特殊的一个字符

        反斜杠转义字符表:
            \'   单引号(')
            \"   双引号(")
            \\   一个反斜杠
            \n   换行
            \r   返回光标至行首
            \t   水平制表符
            \v   垂直制表符
            \f   换页
            \b   退格
            \0   空字符，字符值为零
            \xXX  XX为两位十六进制表示的字符
            \uXXXX   XXXX为四个十六进制表示的Unicode16字符
            \UXXXXXXXX   8个十六进制表示的Unicode32字符

        raw 字符串(原始字符串)
            格式:
                r'字符串内容'
                r"字符串内容"
                r'''字符串内容'''
                r"""字符串内容"""
            作用:
                让转义符号 \ 无效

               当＂＼＂在结尾时，不无效，只能＂＼＼＂
            示例:
                s = 'C:\newfile\test.py'
                print(s)
                print(len(s))
                s = r'C:\newfile\test.py'
                print(s)
                print(len(s))
        
        字符串构造函数:
            str(obj='')  将对象转换为字符串
            示意:
                '123' + 456  # 出错，不合法
                str(True)  # 'True'
                str(None)  # 'None'
                str(3.14)  # '3.14'

        字符串的运算
            + 加号运算符用于拼接字符串
            * 运算符用于生成重复的字符串:
            示例:
                s = "ABC" + "DEF"  # s = 'ABCDEF'
                s2 = '123' * 3  # s2 = '123123123'
                s3 = 2 * 'ABC'  # s3 = 'ABCABC'
            注: 字符串只能和整数相乘

            += *= 运算符,与其它赋合赋值运算符规则相同

        字符串的比较运算
            运算符:    >   >=   <    <=    ==    !=
            规则:
                依次按编码值进行比较，直到最短的字符串结束为止
            示例:
                'A'  < 'B'      # True
                'ABC'  > 'ABB'  # True
                'ABC'  > 'ACB'  # False
                'AB'  < 'ABC'   # True
                'ABC'  > '123'  # True
                'ABC' == 'abc'  # False
                'ABCD' != 'DCBA' # True

        字符串的索引操作
            python的字符串是不可以改变的字符序列

        索引   index
            语法:  字符串[整数表达式]
            说明:
                python 序列都可以用索引来访问序列中的对象
                python 序列的正向索引是多0开始的，第二个索引为1, 最后一个索引为len(s)-1
                python 序列的反向索引是从-1开始的，-1代表最后一个，-2代表倒数第2个，
                        以此类推，第一个是-len(s)
            示例:
                s = 'ABCDE'
                print(s[0])  # A
                print(s[1])  # B
                print(s[4])  # E
                print(s[-1]) # E
                print(s[-5]) # A


        切片 slice
            作用:
                从一个字符串序列中取出相应的元素重新组成一个字符串序列
            语法:
                字符串序列[(开始索引b):(结束索引e)(:(步长s))]
            注:  小括号()括起的部分代表可省略
            说明:
            1.　开始索引是切片开始切下的位置，0代表第一个元素，1代表第二个元素,-1代表最后一个
            2. 结束索引是切片的终止索引(但不包含终止点)
            3. 步长是切片每次获取完当前元素后移动的方向和偏移量
                1)没有步长，相当于取值完成后向右移动一个索引的位置(默认为1)
                2) 当步长为正数时，取正向切片:
                步长默认为1,开始索引默认为0,结束索引默认为len(s)
                步长代表一下次索引的取值的增长值
                3) 当步长为负整数时，取反向切片
                默认的起始位置是最后一个元素，终止位置是第一个元素的前一个位置
            示例:
                s = "ABCDE"
                a = s[1:4]  # a = 'BCD'
                a = s[3:5]  # a = 'DE'
                a = s[3:]   # a = 'DE'
                a = s[:3]   # a = 'ABC'
                a = s[0:3]  # a = 'ABC'
                a = s[1:1]  # a = ''
                a = s[4:2]  # a = ''
                a = s[0:5:2]  # a = 'ACE'
                a = s[1::2]   # a = 'BD' 
                a = s[::2]    # a = 'ACE'
                a = s[::-1]   # a = 'EDCBA'
                a = s[::-2]   # a = 'EDCBA'
                a = s[4:0:-2] # a = 'EC'
                a = s[-2:-5]  # a = ''

        字符串的文本解析方法 split 和join
            S 代表字符串    
            list = S.split(sep=None,maxsplit=-1)  将字串使用sep作为分隔符分割S字串，
                     返回分割后的单词列表。当不给定参数时，用空白字符\n,'',b'',\t
                     作为分隔符分割，并删除空白字符。
                     maxsplit 为最多返回元素数，可对字节串操作


            list = S.splitlines([keepends=Flase]) 将字串使用 换行符\n 作为分隔符分割为字串列表，
                        keepends 为True则返回值包含换行符，默认不包含
                        可对字节串操作

            str = ‘’.join(iterable)   作用于可迭代对象中的字符串(元素要是字符串,不能为字节串)，
                                返回一个中间用S字符进行分隔的字符串

            示例:
                s = 'Beijing is capital'
                L = s.split(' ') # L = ['Beijing', 'is', 'capital']
                    '\\'.join(['C:', 'Programe Files', 'python3'])
            　　 2、L=['aaaa','bbbb','cccc']
           　　　　　s2='#'.join(L)
           　　　　　s2='aaaa#bbbb#cccc'

        Python3 中常用字符串方法(method)

        字符串的方法调用语法:  对象.方法名(方法传参)

            字符串的属性用法示例:

            "abc".isalpha()  # 语法是对的
            123.isalpha()    # 语法是错的

            如下假设字符串变量名为S

                方法                           说明
            S.isdigit()         判断字符串中的字符是否全为数字 
            S.isalpha()         判断字符串是否全为英文字母 
            S.islower()         判断字符串所有字符是否全为小写英文字母 
            S.isupper()         判断字符串所有字符是否全为大写英文字母 
            S.isspace()         判断字符串是否全为空白字符 
            S.center(width[,fill])        将原字符串居中，左右默认填充空格 
            S.count(sub[, start[,end]])   获取一个字符串中子串的个数 
            S.find(sub[, start[,end]])    获取字符串中子串sub的索引,失败返回-1 
            S.strip([chars])     返回去掉左右char字符的字符串(默认char为空白字符) 
            S.lstrip([chars])    返回去掉左侧char字符的字符串(默认char为空白字符) 
            S.rstrip([chars])    返回去掉右侧char字符的字符串(默认char为空白字符) 
            S.upper()            生成将英文转换为大写的字符串 
            S.lower()            生成将英文转换为小写的字符串 
            S.replace(old, new[, count])   将原字符串的old用new代替，生成一个新的字符串 
            S.startswith(prefix[, start[, end]]) 返回S是否是以prefix开头，如果以prefix开头
                                                    返回True,否则返回False, 
            S.endswith(suffix[, start[, end]]) 返回S是否是以suffix结尾，如果以suffix结尾
                                                    返回True,否则返回False 
            以下是不常用的  
            S.title()             生成每个英文单词的首字母大写字符串 
            S.isnumeric()         判断字符串是否全为数字字符 

            空白字符
            是指空格,水平制表符(\t),换行符(\n)等不可见的字符
    元组 tuple
        元组是不可变的序列，同list一样，元组可以存放任意类型数据的容器

      元组的表示方法:
         用小括号() 括起来，单个元素括起来后加逗号(,)区分单个对象还是元组

          创建空元组的字面值:
                 t = ()   空元组

          创建非空元组的字面值表示:
                t = 200,
                t = (20,)
                t = (1, 2, 3)
                t = 100, 200, 300

            元组的错误示例:
                    t = (20)  # t 绑定20这个对象，不是元组
                    x, y, z = 100, 200, 300  # 序列赋值
                    x, y, z = (100, 200, 300)  # 序列赋值
                    x, y, z = [100, 200, 300]  # 序列赋值
                    x, y, z = 'ABC'            # 序列赋值

      元组的运算:

        + += * *=
            + 加号用于拼接元组
            * 用于生成重复的元组

        <  <=  >  >=  ==  !=
            元组的比较运算:
            规则与列表的比较规则完全相同

        in / not in 运算符
            规则与列表的规则完全相同

        索引[],切片[:]/[::]
            索引取值和切片取值的规则与列表完全相同
            元组不支持索引赋值和切片赋值(因为元组不可被改变)

        元组的方法:
            T.index(v[, begin[, end]]) 返回对应元素的索引下标
            T.count(x)  返回元组中对应的元素个数

    列表 list
        列表的定义 ：
        1. 列表是一种容器(通常用来存储计算机的数据对象)
        2. 列表是可以被改变的序列
        3. 列表是由一系列特定元素组成的，元素与元素之间可能没有任何的关联关系，但他们之间有先后顺序关系

        创建空列表的字面值方式
            L = []    # L绑定空列表

        创建非空列表的字面值方式
            L = [1, 2, 3, 4]
            L = ['北京', '上海', '深圳', '西安']
            L = [1, 'Two', 3.14, '四']
            L = [1, 2, [3.1, 3.2, 3.3], 4]

        列表的构造(创建)函数list
            list()   生成一个空的列表，等同于 []
            list(iterable)  用可迭代对象创建一个列表
        示例:
            L = list()         # L = []
            L = list("hello")  # L = ['h', 'e', 'l', 'l', 'o']
            L = list(range(5, 10, 2))  # L = [5, 7, 9]


        列表的运算:
        运算符:    +   +=   *   *= 
            + 用于拼接列表
                x = [1, 2, 3]
                y = [4, 5, 6]
                z = x + y  # [1, 2, 3, 4, 5, 6]
            += 用于将右侧的可迭代对象的数据追加到原列表中
                x = [1, 2, 3]
                x += [4, 5, 6]  # x = [1, 2, 3, 4, 5, 6]
                x = [1, 2]
                x += "AB"  # x = [1, 2, 'A', 'B']
                x = [1, 2]
                x += range(3)  # x = [1, 2, 0, 1, 2]
            * 用于生成重复的列表
                x = [1, 2] * 3  # x = [1, 2, 1, 2, 1, 2]
                x = list("AB")
                x *= 2  # x = ['A', 'B', 'A', 'B']

        列表的比较运算:
        运算符:   <   <=   >   >=  ==  !=
        比较规则：
            同字符串比较规则完全相同
            [1, 2, 3] < [1, 3, 2]  # True
            [1, 2, 3] != [3, 2, 1]  # True
            [1, 'two'] > ['two', 1]  # TypeError 出错

            [1, 'two', 3.14] < [1, '二', 3]

        列表是可迭代对象:
            L = [2, 3, 5, 7, 11]
            for x in L:
                print(x)

        列表的in / not in 运算符:
        判断一个元素是否存在于列表中,如果存在返回True,否则返回 False
            in 和 not in 的返回值相反
        示例:
            x = [1, 'two', 3, '四']
            3 in x   # True
            4 not in x  # True
            '3' in x   # False

        列表的索引操作：
            语法:       列表[整数表达式]
        用法:
            等同于字符串的索引操作(索引分正向索引和反向索引，规则与字符串完全相同)

        列表的索引赋值
                列表是可变的序列，可以通过索引赋值改变列表中的元素
            语法:
                列表[整数表达式] = 表达式

        列表的切片
            语法：    列表[:]
                    列表[::]
                列表的切片取值返回一个列表,规则等同于字符串的切片规则
            例如:
                L = [0, 1, 2, 3, 4, 5, 6, 7, 8]
                L2 = L[1::2]  # L2 = [1, 3, 5, 7]

        列表的切片赋值:
            作用:
                可以改变原列表的排列，可以插入和修改数据
                可以用切片改变列表对应的元素的值
            语法:
                列表[切片slice] = 可迭代对象
            说明:
                赋值运算符的右侧必须是一个可迭代对象
            示例:
                L = [2, 3, 4]
                L[0:1] = [1.1, 2.2]  # L = [1.1, 2.2, 3, 4]
                L[2:] = [3.3, 4.4, 5.5]  # L = [1.1, 2.2, 3.3, 4.4, 5.5]
                L[:] = [3, 4]
                L[0:0] = [1, 2]
                L = [3, 5]
                L[1:1] = [4.1, 4.2]  # [3, 4.1, 4.2, 5]
                L = [3, 5]
                L[2:2] = [6]  # L = [3, 5, 6]
                L = [3, 5, 6]
                L[1:2] = []  # 删除了中间的5
                L = [1, 6, 10]
                L[1:2] = range(2, 10)  # L = [1, 2, 3....10]
                L = ['D', 'E']
                L[:0] = "ABC"  # L = ['A', 'B', 'C', 'D', 'E']
                L = [1, 2, 3, 4, 5, 6]
                L[::2] = "ABC"
                L = [1, 2, 3, 4, 5, 6]
                L[::-2] = "DEF"
            切片赋值注意事项:
            对于步长不等于1的切片赋值，赋值运算符的右侧的可迭代对象
            提供的数据元素的个数一定要等于切片切出的片数
        如:
            L = [1, 2, 3, 4, 5, 6]
            L[::2] = "ABC"  # 正确
            L[::2] = "ABCDE" #错误

        del 语句用于删除列表的元素
            语法:
                del 列表[索引]
                del 列表[切片]
            示例:
            L = [0, 1, 2, 3, 4, 5, 6]
            del L[0]  # L = [1, 2, 3, 4, 5, 6]
            del L[::2] # L = [2, 4, 6]

        列表推导式 list comprehension
                列表推导式是用可迭代对象生成列表的表达式
            作用:
                    用简易方法生成列表
            语法:
                    [表达式 for 变量 in 可迭代对象]
                或
                    [表达式 for 变量 in 可迭代对象 if 真值表达式]
            说明:
        for in 表达式的if子句可以省略，省略后将对所有生成的对象进行求值处理
            示例:
                # 生成一个数值为 1 ~ 9 的平方的列表
                L = [x**2 for x in range(1, 10)]


            列表推导式的嵌套:
                语法:
                [ 表达式 for 变量1 in 可迭代对象1 if 真值表达式1
                        for 变量2 in 可迭代对象2 if 真值表达式2]
                示例:
                    L = [x + y for x in "ABC" for y in "123"]
        
        Python3中常用的列表方法（method)
            •见:help(list)
            方法                        意义


        L.index(v [, begin[, end]]) 返回对应元素的索引下标, begin为开始索引，end为结束索引,
                                        当 value 不存在时触发ValueError错误 
        L.insert(index, obj) 将某个元素插放到列表中指定的位置 
        L.count(x) 返回列表中元素的个数 
        L.remove(x) 从列表中删除第一次出现在列表中的值 
        L.copy() 复制此列表（只复制一层，不会复制深层对象) 
        L.append(x) 向列表中追加单个元素 
        L.extend(lst) 向列表追加另一个列表 
        L.clear() 清空列表,等同于 L[:] = [] 
        L.sort(reverse=False) 将列表中的元素进行排序，默认顺序按值的小到大的顺序排列 
        L.reverse() 列表的反转，用来改变原列表的先后顺序 
        L.pop([index]) 删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系 

    字典 dict
      什么是字典:
          1. 字典是一种可变的容器，可以存储任意类型的数据
          2. 字典中的每个数据都是用'键'(key)进行索引，而不象序列可以用整数下标来进行索引
          3. 字典中的数据没有先后关系，字典的存储是无序的
          4. 字典中的数据以键(key)-值(value)对形式进行映射存储
          5. 字典的键不能重复，且只能用不可变类型作为字典的键

      字典的字面值表示方法:
         字典的表示方式是以{} 括起来，以冒号(:) 分隔键-值对,各键-值对之间用逗号(,)分割开 

      创建空字典的字面值:
          d = {}    # d 绑定空字典

      创建非空字典的字面值:
            d = {'name': 'weimingze', 'age': 35}
            d = {1: 'One', 2: 'Two', 3: 'Three'}
            d = {'国籍': '中国'}
            d = {1: [1, 2, 3], 'abc': (1.1, 2.2, 2.3)}
            d = {123: list("123")}
            d = {'a': {'b': 200, 'c': [1, 2, 3]}}
            d = {(1970, 1, 1): 'computer year'}

      字典的构造函数dict
            dict()  生成一个字的字典 等同于 {}
            dict(iterable)  用可迭代对象初始化一个字典
            dict(**kwargs)  用关键字传参形式创建一个字典

            示例:
                d = dict()
                d = dict([('name', 'tarena'), ['age', '15']])
                d = dict(name='tarena', age=15)

       字典的键(key) 必须为不可变类型
            bool, int, float, complex, str, tuple, frozenset, bytes(后面再讲)

       字典的值(value) 可以是任意类型
  
      字典的基本操作:
         字典的键索引
              用[] 运算符可以获取字典内'键'对应的值
              也可以用[] 运算符来修改'键'对应的值
        键索引的语法:
             字典[键]

            示例:
                获取值:
                d = {'name': 'tarena', 'age': 15}
                print(d['name'], '的年龄是:', d['age'])


        添加/修改字典的元素
            语法:
                字典[键] = 值
            说明:
                键不存在时，创建键，并绑定对应的值
                当键存在时，修改键绑定的值
            示例:
                d = {}
                d['name'] = 'tarena'  # 创建新的键值对
                d['age'] = 15
                d['age'] = 16  # 修改'age'所对应的值
            
        删除字典元素
                del 字典[键]
            示例:
                d = {'name': 'tarena', 'age': 15}
                del d['name']
            

        字典的成员资格判断 in 运算符
          可以用in运算符判断一个键是否存在于字典中，如果'键'存在则返回True,
          否则返回False   ， not in 与 in 结果相反

            示例:
                d = {'name': 'tarena', 'age': 15}
                if 'name' in d:
                    print('name 在字典中')

                print(15 in d)  # False,只判断键，不判断值

        字典的迭代访问
            字典是可迭代对象，字典只能对键进行迭代访问
              示例:
                d = {'name': 'tarena', 'age': 15}
                for k in d:
                    print(k, '对应的值是: ', d[k])

        可以用于字典的内建函数
            len(x) 返回字典的键值对个数
            max(x) 返回字典的键的最大值
            min(x) 返回字典的键的最小值
            sum(x) 返回字典中所有键的和
            any(x) 真值测试，只要有一个键为True,返回True
            all(x)  真值测试，当全部键为真值是，返回True

            示例:
                d = {0: '零', 5: '伍', 8: '捌', 3: '参'}
                print(len(d))  # 4
                print(max(d))  # 8
                print(min(d))  # 0
                print(sum(d))  # 16
                print(any(d))  # True
                print(all(d))  # False

      字典推导式:
            字典推导式是用可迭代对象创建字典的表达式

            语法:
                {键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}
            说明:
                if 子句部分可省略
            示例:
                生成一个字典，键为数字(10以内), 值为键的平方
                d = {x : x ** 2 for x in range(10)}

    集合 set
        集合的是可变的容器
        集合内的数据对象都是唯一的(不能重复多次的)
        集合是无序的存储结构，集合中的数据没有先后关系
        集合内的元素必须是不可变对象
        集合是可迭代对象
        集合是相当于只有键没有值的字典(键则是集合的数据)

      创建空集合
            s = set()

      创建非空集合
         s = {1, 2, 3}
         s = {3.14, True, (1970,1,1), "hello"}

      集合的构造函数 set
          set()  创建一个空的集合对象(不能用{}创建空集合)
          set(iterable)  用可迭代对象创建一个新的集合对象
        示例:
            s = {1, 3, 5, 7}
            s = set("ABC")
            s = set("ABCCBA")
            s = set({1:'1', 2:'2', 5:'5'})
            s = set([1, 0, 3.14, "hello"])
            s = set(('abc', '123', True))

      集合的运算:
            交集 &    并集 |    补集 -     对称补集 ^      子集 <      超集 >

        & 生成两个集合的交集
            s1 = {1, 2, 3}
            s2 = {2, 3, 4}
            s3 = s1 & s2  # s3 = {2, 3}

        |  生成两个集合的并集
            s1 = {1, 2, 3}
            s2 = {2, 3, 4}
            s3 = s1 | s2  # s3 = {1, 2, 3, 4}

        - 生成两个集合的补集 
            s1 = {1, 2, 3}
            s2 = {2, 3, 4}
            s3 = s1 - s2  # 生成属于s1但不属于s2的所有元 素的集合

        ^ 生成两个集合的对称补集
            s1 = {1, 2,i 3}
            s2 = {2, 3, 4}
            s3 = s1 ^ s2  # (s1 - s2) | (s2 - s1)
                            # {1, 4}

        > 判断一个集合是另一个集合的超集
        < 判断一个集合是另一个集合的子集
            s1 = {1, 2, 3}
            s2 = {2, 3}
            s1 > s2  # True  s1 为 s2的超集
            s1 < s2  # False  s2 为 s1的子集

        == != 集合相同/不同  
            s1 = {1, 2, 3}
            s2 = {3, 2, 1}
            s1 == s2  # 


        in , not in 运算符
            等同于字典in,not in,
            作于集合中，判断某个值是否存在于集合中

        集合和字典的优点:
            in / not in运算符的判断速度快些

        能用于集合的函数:
            len(x), max(x), min(x), sum(x), any(x), all(x)

      Python3 集合的方法
            方法                       意义


        S.add(e) 在集合中添加一个新的元素e；如果元素已经存在，则不添加 
        S.remove(e) 从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误 
        S.discard(e) 从集合S中移除一个元素e,在元素e不存在时什么都不做; 
        S.clear() 清空集合内的所有元素 
        S.copy() 将集合进行一次浅拷贝 
        S.pop() 从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常 
        S.update(s2) 等同于 S \ 
        
        S.difference(s2) S - s2 补集运算，返回存在于在S中，但不在s2中的所有元素的集合 
        S.difference_update(s2) 等同于 S -= s2 
        S.intersection(s2) 等同于 S & s2 
        S.intersection_update(s2) 等同于S &= s2 
        S.isdisjoint(s2) 如果S与s2交集为空返回True,非空则返回False 
        S.issubset(s2) 如果S与s2交集为非空返回True,空则返回False 
        S.issuperset(...) 如果S为s2的子集返回True,否则返回False 
        S.symmetric_difference(s2) 返回对称补集, 等同于 S ^ s2 
        S.symmetric_difference_update(s2) 等同于 S ^= s2, 用 S 与 s2 的对称补集更新 S 
        S.union(s2) 生成 S 与 s2的全集, 等同于 S 

      集合推导式
            集合推导式是用可迭代对象生成集合的表达式
        语法:
            {表达式 for 变量 in 可迭代对象 [if 真值表达式]}

          注: [] 括号部分可以省略
  
        示例:
            L = [1, 3, 5, 7, 2, 4, 6, 8, 1, 3, 5]
            s = {x for x in L}

      集合推导式可以嵌套:
           语法同列表推导式一致!

    固定集合 frozenset
           固定集合是不可变的，无序的， 含有唯一元素的集合
        作用:
           固定集合可以作为字典的键，还可以作为集合的值

      固定集合的构造函数:
          frozenset()  创建一个空的固定集合
          frozenset(iterable)  用可迭代对象创建固定集合
        示例:
          f = frozenset()   # 空固定集合
          f = frozenset([1, 3, 5, 7])  # f = frozenset({1, 3, 5, 7})

      固定集合的运算:
             & 交集， | 并集,  - 补集, ^ 对称补集
             < <= > >= == !=
              in / not in 
              (以上运算符和 集合 set中的用法完全一致)

      固定集合的方法
           相当于集合的全部方法去掉修改集合的方法

    字节串(也叫字节序列)  bytes
        作用：存储以字节为单位的数据
        说明：字节串是不可改变的序列
              7 6 5 4 3 2 1 0  序列
              1 0 0 1 1 0 1 1　字节

        字节 byte ：字节是0~255之间的数，用来表示字节的取值，８bit
                   0(0b00000000) ~ 255(0b11111111)
        
        位 bit：

      创建空字节串的字面值
            b''
            b""
            b''''''
            b""""""

      创建非空字节串的字面值
            b'AAAA'
            b"dfsd"
            b'\x41\x42\x43\x44'
            b'hello'
            b'中文'   #False

      字节串的构造函数 bytes
            bytes()  生成一个空的字节串，等同于b''
            bytes(整形可迭代对象)  #用可迭代对象初始化一个字节串
            bytes(整数n) 生成n个值为0的字节串
            bytes(字符串，encoding='utf-8') 用字符串的转换编码
                    生成一个字节串

        bytes 的运算
            同其他的序列的运算规则相同
            +   +=   *   *=
            <   <=    >    >=    !=
            in  /  not in   同字符串
            索引/切片

        能用于字节串和字节数组的函数
            len(x)  max(x)   min(x)  sum(x) 
            any(x)   all(x)

        bytes 和  str 的区别
            bytes 存储字节(字节是0~255的整数)
            str  存储unicode字符(字符是0~65536的整数)

        bytes 和 str 转换
            
                编码(encode)
            str------------>bytes
            b = s.encode(encodeing='utf-8')

                编码(decode)
            bytes---------->str
            s = b.decode(decodeing='utf-8')

    字节数组 bytearray
            可变的字节序列
        格式：　
        　　　bytearray(b"")

      字节数组的构造函数 
        bytearray()  生成一个空的字节数组，等同于b''
        bytearray(整形可迭代对象)  #用可迭代对象初始化一个字节数组
        bytearray(整数n) 生成n个值为0的字节数组
        bytearray(字符串，encoding='utf-8') 用字符串的转换编码
                            生成一个字节数组
        例：   
            ba=bytearray(b'a1b2c3d4')
            b=bytes(ba[1:8:2])
            b1=bytes(ba[:7:2])
            print(b,'\n',b1)
            s=ba.decode('utf-8')
            st=s.upper()
            print(st)
            bba=st.encode('utf-8')
            print(bba)

表达式 expression
    由一个数字 或 运算符 函数等组成  能返回对象的就是表达式
        作用:  通常让计算做一些事情并返回结果
            如:
              1 + 2
              1 + 2 * 3 + 4 / 5
              max(a,b,c)
    括号分组子表达式:
        ()内部的表达式先进行计算
    
  函数调用表达式
      语法： 函数名(传参列表)
      说明:
         函数调用是表达式，此表达式一定会返回一个对象的引用关系。如果不需要返回值时，
         通常返回None对象的引用关系

   if 语句的真值表达式
        if 100:
          print('真值')
        等同于:
        if bool(100):
          print('真值')
        if 语句 真值表达式返回的对象要用bool(x)取值后再决定执行哪儿条语句

  条件表达式:
      语法:    (True)表达式1  if  真值表达式  else  表达式2(False)
      作用：
           根据真值表达式的取值(True/False) 来决定执行表达式1或表达式2,并返回结果

  字符串的格式化表达式
      作用:
          生成一定格式的字符串
      语法格式:
          格式字符串 % 参数值
          格式字符串 % (参数值1, 参数值2, ...)
      说明:
          格式化字符串中以%开头的为占位符,占位符的位置将用参数值替换
      示例:
          fmt="name:%s, age: %d"
          name = "tarena"
          age = 15
          s = fmt % (name, age)  # s = 'name:tarena, age: 15'
          print()

    格式化字符串中的占位符和类型码:
            %s     字符串,使用str(obj)转为字符串
            %r     字符串，使用repr(obj) 转为字符串
            %c     整数转为字符串，使用chr(i) 函数
            %d     十进制整数
            %o     八进制整数
            %x     十六进制整数(字符a-f小写)
            %X     十六进制整数(字符A-F大写)
            %e     指数型浮点数(e小写)  如 2.9e+10
            %E     指数型浮点数(E大写)  如 2.9E+10
            %f,%F  浮点十进制形式
            %g,%G  进制进形式浮点或指数浮点自动转换
            %%     等同于一个%字符

      占位符和类型码之间的格式语法:
            % [- + 0 宽度.精度] 类型码
            -   左对齐(默认是右对齐)
            +   显示正号
            0   左侧空白位置补零
            宽度: 整个数据输出的宽度
            精度: 保留小数点后多少位,默认6位
            示例:
              "%10d"  % 123    # '       123'
              "%+10d"  % 123   # '      +123'
              "%-10d"  % 123   # '123       '
              "%10s" % "ABC"   # '       ABC'
              "%05d" % 123     # '00123'
              "%f" % 3.1416926535897932  # '3.141593'
              "%7.2f" % 3.1416926535897932 # '   3.14'

    lambda 表达式(又称匿名函数)
        作用:
            创建一个匿名函数对象
            同 def 类似,但不提供函数名
        
        语法： lambda [函数形参列表]:表达式(可嵌套)
            例：  
                def myadd(x,y):
                    　return x+y

                myadd=lambda x,y: x+y
        说明:
            1. lambda 只是一个表达式，它用来创建一个函数对象
            2. 当lambda表达式调用时，先执行冒号(:)后的表达式，并返回表达式的结果的引用关系
            3. lambda 表达式创建的函数只能包含一条表达式
            4. lambda 比函数简单且可以随时创建和销毁，有利于减少程序的偶合度
    
    生成器表达式
        语法：(表达式 for 变量 in 可迭代对象 [if 真值表达式])

            说明： if 子句可以省略
            作用： 用推导式形式创建一个新的生成器

    集合推导式
            集合推导式是用可迭代对象生成集合的表达式
        语法:
            {表达式 for 变量 in 可迭代对象 [if 真值表达式]}

          注: [] 括号部分可以省略
  
        示例:
            L = [1, 3, 5, 7, 2, 4, 6, 8, 1, 3, 5]
            s = {x for x in L}

    列表推导式 list comprehension
            列表推导式是用可迭代对象生成列表的表达式
        作用:
                用简易方法生成列表
        语法:
                [表达式 for 变量 in 可迭代对象]
            或
                [表达式 for 变量 in 可迭代对象 if 真值表达式]
        说明:
             for in 表达式的if子句可以省略，省略后将对所有生成的对象进行求值处理
        示例:
             # 生成一个数值为 1 ~ 9 的平方的列表
            L = [x**2 for x in range(1, 10)]

    字典推导式:
            字典推导式是用可迭代对象创建字典的表达式

        语法:
            {键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}
        说明:
            if 子句部分可省略
        示例:
             生成一个字典，键为数字(10以内), 值为键的平方
            d = {x : x ** 2 for x in range(10)}

运算符:
    正负号运算符:
           + (正号)      - (负号)
        语法:
               + 表达式
               - 表达式
        说明:
              这是一元运算符(只有一个数据参加运算)
         示例:
             a = 5
             b = -a
             c = +a

    算术运算符:
         +  加法   -  减法   *  乘法   /  除法   // 地板除floordiv    %  求余   ** 幂运算
      
      / 除法
        除法得到的数是浮点型数，不会丢弃小数部分
        1 / 3  # 得 0.333333333333
        8 / 2  # 得 4.0

      // 地板除
        除的结果云掉小数部分向下取整
        如:
          7 / 3        # 得 2.333333333333
          7 // 3       # 得 2
          3.25 // 1.5  # 得 2.0
      % 求余
        如:
          7 % 3       # 得 1
          3.25 % 1.5  # 得 0.25
      ** 幂运算
        格式:
          x ** y
          意为 x的y次方
        如:
          4 ** 2  # 得 16
          3 ** 4.0  # 得 81.0
    复合赋值算术运算符  

            运算符         说明
            y += x     等同于 y = y + x
            y -= x     等同于 y = y - x
            y *= x     等同于 y = y * x
            y /= x     等同于 y = y / x
            y //= x    等同于 y = y // x
            y %= x     等同于 y = y % x
            y **= x    等同于 y = y ** x
            例:
              x = 100
              x *= 2  # x = 200
              x = 100
              x = x * 2  # x = 200

        当变量对象为可变对象时(list)，不会创建新对象

    in / not in 运算符:
      语法:
            对象 in  容器对象
            对象 not in  容器对象
      作用:
           用于判断某个元素是否在于相当前容器中。如果出现过返回True,否则返回False
           (str/list/dict/tuple/set/frozenset/.....)
      示例:
            s = 'welcome to tarena!'
            'to' in s  # True
            'weimingze' in s # False
            'e t' in s  # True

    is / is not 运算符
      语法:
              x is y
               x is not y
      作用:  判断两个对象是否是同一个对象,当是同一对象时返回True,否则返回False
      说明:  is not 返回值与is 相反

    比较运算符
      运算符:
        < 小于   <= 小于等于   > 大于   >= 大于等于     ==  等于    !=  不等于
      语法:
            左表达式 < 右表达式
      说明:
          比较运算返回布尔类型的值
        例:
          20 < 100       # True
          300 >= 20      # True
          1 == 2         # False
          x = 70
          y = 70
          x != y         # False
          0 <= x <= 100  # True
 
    布尔运算  bool    (与 if 语句组合，逻辑判断)
        运算符:   not  and   or

      布尔非操作 not
        语法:   not x
        作用:
            对表达式x进行布尔取非.如bool(x) 为True则
            返回False, 否则返回True
        示例:
            not True  # 返回False
            not False  # 返回True
            month = 10
            if not 1 <= month <= 12:
                print('month 不在1~12之间')

      布尔与操作 and
          语法:   x and y      注: x, y 代表表达式
          作用:
                优先返回假值对象
                当x的布尔值为False时，返回x, 否则返回y
          示例:
              True and True   # True
              True and False  # False
              False and True  # False
              False and False # False
              0 and 0.0       # 0
              1.2 and 100     # 100


      布尔或操作  or
         语法： x or y
         作用:
               优先返回真值对象
               当x为True时返回x,否则返回y
          示例:
              True or True    # True
              True or False   # True
              False or True   # True
              False or False  # False
              0 or 0.0    # 0.0
              100 or 200  # 100

    运算符的优先级
                            运算符                                 描述

          (), [], {key: value}, {}            元组表达式、列表表达式、字典表达式、集合表达式 
          x[index], x[index:index], x(arguments...), x.attribute 索引，切片，函数调用，属性引用 
            **        指数 (最高优先级) 
          ~, +, -     按位翻转, 正号,负号 
          *, /, %, //     乘，除，取模和地板除 
          +, -     加法, 减法 
          >>, <<     右移, 左移运算符 
          &    位与(AND) 
          ^    位异或(XOR) 
          |    位或(OR) 
          <=, <, >, >=, ==, !=,
          is, is not, in, not in  比较,身份测试,成员资格测试 
          not 布尔非 
          and 布尔与 
          or 布尔或 
          if - else              条件表达式 
          lambda                lambda表达式 
      混合类型自动升级
            1 + 2.14 返回类型为浮点型 3.14
            3 + 4.0  返回 7.0



变量 variable
     变量是绑定一个对象的"标识符"   
     在python中一个变量只能绑定一个对象地址空间(值)，和指针指向相同
     在python中只有变量，没有常量，且变量是没有类型的。
     变量的类型和值就是它绑定的对象的类型和值
     变量有作用域：Ｌ　Ｅ　Ｇ　Ｂ

  标识符的命名规则:
        必须为字母或下划线开头，后跟字母或下划线或数字
        不能使用python的关键字

    说明:
        python的变量名区分大小写
            合法的标识符（变量名) 举例 ：
                  abc  a1b2 _abc  __Abcd  var  
            不合法的标识符:
                  1a2b  $ABC  +a  -b  #ABC @ ABC
           python关键字:
              True, False, None, is, del, if, elif ...等

  函数变量
        函数名是变量，它在def 语句创建函数时绑定一个函数体

  全局变量和局部变量
    局部变量: local variable
      1. 定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
      2. 局部变量只能在函数内部使用
      3. 局部变量在函数调用时才能够被创建，在函数调用之后会自动销毁

    全局变量 global variable
         定义在函数外部，模块内部的变量称为全局变量
         全局变量所有函数都可以直接访问(但函数内不能将其直接赋值)

      globals() / locals()函数:
          globals() 返回当前全局作用域内变量的字典
          locals()  返回当前局部作用域内变量的字典

语句  statements
    语句是程序最小执行单位
    语句可以由一个表达式或多个表达式组成
    python建议一条语句写在一行内,多条语句写在一行内需要用分号(;) 分开
      示例:
          print("hello")
          x = 100 + 200
          print(x)
          # 写在一行内为:
          print("hello"); x = 100 + 200; print(x)
    
    显式换行:
        折行符 \ (读作反斜杠)
        折行符必须放在一行的末尾，来示意解释执行器下一行也是本行的语句
    隐式折行
        所有的括号的内容换行，称为隐式换行
        括号包括()  []  {}
  
  赋值语句
      = 
    语法:  变量名 = 表达式
        或
          变量名1 = 变量名2 ....= 表达式
        或
          变量名1, 变量名2,... = 表达式1，表达式2，......    (tuple 赋值方式)
    作用:
        1. 创建一个变量，此变量用来绑定数据对象
        2. 修改一个变量的绑定关系，让其绑定另一个对象(数据，函数，类)
    说明:
        右边为对象时，创建新对象.python中不释放的对象除外（Ｆalse,True,None,小整数对象池...)
        当当前作用域内变量不存在时，创建该变量，同时定义变量的作用域．同时将变量绑定在一个对象上
        当变量存在时，改变此变量绑定的对象
        一个变量只能绑定一个对象
        多个变量可以同时绑定同一个对象
      示例:
          pi = 3.1415926
          pi2 = pi  # pi变量 和 pi2 变量同时绑定 3.1415926
          x = y = 100  # x变量和 y变量同时绑定 100
          x, y = 100, 200  # 序列赋值

  del 语句:
  　　１．用于删除变量
    　　语法:     del 变量名
    作用: 用于删除变量，同时解除与对象的关联关系，如果可能能释放对象

    　２．用于删除列表的元素
    示例:
        del L[2]   #删除对应索引的单个元素
        del L[:2]  #删除切片出来的部分
      注意：用for语句删的时候，列表索引会改变，循环次数减少

      3.删除字典键值对
         语法：del 字典[键]

      4.删除字节数组元素
        　del bytearray(b'123dsfwf')[2]   #删除对应索引的单个元素
        　del bytearray(b'123dff')[:2]  #删除切片出来的部分
      　　

  if 语句:
    作用:  让程序根据条件选择性的执行某条语句或某些语句
    语法:
            if 真值表达式1:
                语句块1       # 四格缩进
            elif 真值表达式2:
                语句块2
            elif 真值表达式3:
                语句块3
            ...
            else:
                语句块
    说明:
          elif 可以有0个，1个或多个
          else 可以有0个或1个
    if 语句的嵌套
          if 语句本身是由多条子句组成的一条复合语句
          if 语句可以作为语句嵌套到另一个语句的内部
  pass 语句
    作用:  通常用来填充语法空白
           pass 又名空语句
    语法:
           pass

  while 语句 
      作用:
            根据一定条件，重复的执行一条语句或多条语句
      语法:
            while 真值表达式:
                语句块1        #  四格缩进
            else:
                语句块2
      说明:
        1. 先执行真值表达式,测试布尔值是否为True或False
        2. 如果真值表达式测试值为True,则执行语句块1，然后再返回到第1步,重重进行测试
        3. 如果真值表达式测式值为False, 则执行else子句中的语句块2，然后结
            束此while语句，如果没有else子句，则直接结束此while语句的执行
        注： 
          else 子句部分可以省略（同 if语句类似)

      while 语句的注意事项:
         要控制循环真值表达式的值来防止'死循环'
         通常用真值表达式内的循环变量来控制循环条件
         通常在循环语句块内改变循环变量来控制循环次数和变量走向

    while 语句的嵌套
      while 语句本身是语句，和其它语句一样，可以嵌套放入任何复合语句中

  for 语句 (while语句一种))
      作用:  用来遍历可迭代对象的数据元素
      for 语法
            for 变量列表 in  可迭代对象:
                语句块1
            else:
                语句块2
        说明:
          当循环内部用break语句终止循环时，else子句部分的语句不会执行

      for 语句嵌套:
        示例:
          for x in "ABC":
              for y in "123":
                  print(x + y)

      死循环
        死循环是指循环条件一直成立的循环
        死循环通常用break语句来终止循环，在函数中可用return语句 
        死循环的else子句永远不会执行

  break 语句
      作用:
        用于循环语句(while, for)中,用来终止本循环语句的执行
      说明:
        1. 当break语句执行后，此循环语句break之后的语句将不再执行
        2. break 语句通常和 if 语句组合使用
        3. break语句终止循环时，循环语句else子句的语句将不会执行
        4. break 语句只能终止当前循环语句的执行，如果有循环嵌套时，不会跳出嵌套的外重循环
        5. break 语句只能在循环语句(while或for语句)内部使用

  continue 语句:
      continue语句的作用:
          用于循环语句中(while, for语句),不再执行本次循环内 continue之后的语句，重新开始一次新的循环
        说明:
            1. 在while语句中执行continue语句，将会直接跳转到 while语句的直值表达式处重新判断循环条件
            2. 在for 语句中，执行continue语句，将会从可迭代对象中取一下元素绑定变量后再次进行循环

  def 语句:
       作用:   创建函数
        语法:
            def 函数名(形参列表):
            语句块
        说明:
            1. 函数的名字就是语句块的名称
            2. 函数名的命名规则与变量名相同（函数名必须是标识符）
            3. 函数名是一个变量(不要轻易对其赋值)
            4. 函数有自己的名字空间，在函数外部不可以访问函数内部的变量，在函数内可以访问函数外部的变量,但不能修改此变量.
            5. 函数如果不需要传入参数，形参列表可以为空
            6. 语句部分不能为空，如果为空需要填充pass

  return 语句
        语法:
            return [表达式]
            注: []  代表可省略
        作用:
            用于函数中，结束当前函数的执行，返回到调用该函数的地方，同时返回一个对象的引用关系

        return 语句说明
            1. return 语句后跟的表达式可以省略，省略后相 当于return None
            2. 如果函数内没有return 语句，则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)
  yield 语句
       语法:     yield 表达式
    
       说明： yield 用于 def 函数中，目的是将此函数作用生成器
                   函数使用
             yield 用来生成数据，供迭代器的next(it)函数取值
               有 yield语句的函数不会return，只返回生成器

                def fn():
                    yield 2
                    yield 3
                    yield 5
                    yield 7
                gen=fn()    # gen 是一个生成器对象
                it=iter(gen)
                print(next(it))     # 2
                print(next(it))     # 3
                print(next(it))     # 5
                print(next(it))     # 7
                print(next(it))     # StopIteration        
  global 语句
        作用:
            1. 告诉解释执行器 global 语句声明的一个或多个变量，这些变量的作用域为模块级的作用域，也称作全局变量
            2. 全局声明(global)将赋值语句操作的变量映射到模块文件内部的作用域

        语法:
            global 变量1, 变量2, ...
    
        说明:
            1. 全局变量如果要在函数内部被赋值，则必须经过全局声明（否则会被认为是创建局部变量)
            2. 全局变量在函数内部不经过声明就可以直接访问(变量已经存在并关联一个对象)
            3. 不能先声明局部变量，再用global声明为全局变量，此做法不附合规则
            4. global变量列表里的变量名不能出现在此作用域的形参列表里

  nonlocal 语句
        作用:
            告诉解释执行器，nonlocal声明的变量不是局部变量，也不是全局变量，它是外部嵌套函数内的变量

        语法:
            nonlocal 变量名1, 变量名2, ....
        
        说明:
            1. nonlocal 语句只能在被嵌套的函数内部进行使用
            2. 访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
            3. 当有两层或两层以上函数嵌套时，访问nonlocal变量只对最近的一层变量进行操作
            4. nonlocal语句的变量列表里的变量名，不能出现在此函数的参数列表中 

函数   function
  函数基础语法
      什么是函数:
            函数是可以重复执行的语句块，可以重复调用
        作用:
            1. 用 于封装语句块，提高代码的重用性
            2. 定义用户级别的函数

        语法:
                def 函数名(形参列表):
                    语句块
        说明:
            1. 函数的名字就是语句块的名称
            2. 函数名的命名规则与变量名相同（函数名必须是标识符）
            3. 函数名是一个变量(不要轻易对其赋值)
            4. 函数有自己的名字空间，在函数外部不可以访问函数内部的变量，在函数内可以访问函数外部的变量,但不能修改此变量.
            5. 函数如果不需要传入参数，形参列表可以为空
            6. 语句部分不能为空，如果为空需要填充pass
            7.　函数传参传递的是引用关系，不创建新对象
    函数的文档字符串
            函数内第一次未赋值给任何变量的字符串是函数的文档字符串

            语法： def 函数名(参数列表)：
                    "函数的文档字符串"
                    函数语句块
            示例：
                def cba():
                    """这是一块文档字符串......."""
                    pass
                >>>help(cba)

            作用：用来描述说明函数的使用方法

    函数的 __doc__属性
            
            __doc__属性用于记录函数的文档字符串

        如：print(cab.__doc__)

    函数定义语句(def语句)的完整语法

            [@装饰器1]          #  一定要换行
            [@装饰器2]
            [@......]
            def 函数名([位置形参],[*元组形参],[命名关键字形参],
                        [**字典形参]):
                """文档字符串"""
                语句块

        缺省参数默认实参是可变序列时，序列会随函数保存并改变，
            让函数不得不可重入 ，尽量避免，或进入函数后list=None
    
    函数变量
        函数名是变量名，它在def 语句创建函数时绑定一个函数
        例：def fn()
            　pass
            f1=fn
            f1()=fn()   # f1与fn 同时绑定函数

        两个函数变量交换,函数形参列表要一样
                f1,f2=f2,f1

        一个函数可以作为另一个函数的实参传递(绑定关系，加()调用)
                    def f1():
                        print('f1')
                    def f2():
                        print('f2')
                    def fx(fn):
                        print(fn)  # f1
                    fn()       # fn()==f1()
                    fx(f1)

        函数可以作为另一个函数的返回值
            def get_function():
                s=input('请输入您要做的操作:')
                if s =='求最大':
                    return max
            L=[2,3,4,5,6,7]
            f=get_function()
            print(f(L))        # 7

    函数的嵌套定义
            函数嵌套定义是指一个函数里用def语句来创建其它的函数的情况

       示例:
            def fn_outter():
                print("fn_outter被调用")
                def fn_inner():
                    print("fn_inner被调用")
                fn_inner()
                fn_inner()
                print("fn_outter调用结束")
            fn_outter()

    lambda 表达式(又称匿名函数)
        作用:
            创建一个匿名函数对象
            同 def 类似,但不提供函数名
        格式:
            lambda : 表达式
        说明:
            1. lambda 只是一个表达式，它用来创建一个函数对象
            2. 当lambda表达式调用时，先执行冒号(:)后的表达式，并返回表达式的结果的引用关系
            3. lambda 表达式创建的函数只能包含一条表达式
            4. lambda 比函数简单且可以随时创建和销毁，有利于减少程序的偶合度

    函数调用
         函数名(实际调用传递参数)
             注:实际调用传递参数，以后简称实参

        说明:
            1. 函数调用是一个表达式
            2. 如果函数内部没有return语句，函数调用完毕后返回None对象
            3. 如果函数需要返回其它的对象需要用到 return 语句

    return 语句
        语法:
            return [表达式]
            注: []  代表可省略
        作用:
            用于函数中，结束当前函数的执行，返回到调用该函数的地方，同时返回一个对象的引用关系

        return 语句说明
            1. return 语句后跟的表达式可以省略，省略后相 当于return None
            2. 如果函数内没有return 语句，则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)

    函数的参数传递
        传递方式:
                位置传参
               　　 序列传参
                关键字传参
                　　字典关键字传参

      位置传参:
        实际参数(实参) 的对应关系与形式参数(形参)的对应关系是按位置来依次对应的

        示意:
            def mymin(a, b, c):
                pass

            mymin(    1, 2, 3)
        说明:
            实参和形参通过位置进行传递和匹配
            实际参数的个数必须与形式参数的个数相同
        　　
        序列传参:
            序列传参是指在函数调用过程中，用 * 将序列拆解后按位置进行传递的传参方式

          说明:
              序列传参时，序列拆解的位置将与形参一一对应
              序列的位置信息对应相应的形参位置
            语法：function(*str/list/tuple)
          例：	def aaa(a,b,c,d,e,f):
    			  print('a=',a)
    			  print('b=',b)
    			  print('c=',c)
    			  print('d=',d)
   				  print('e=',e)
    			  print('f=',f)
			    e={1,2,3,4,5,6}
			    aaa(*e) 

        关键字传参
             关键字传参是指传参时，按着形参的名称给形参赋值
             实参和形参按形参名进行匹配
          例：def function(a,b,c)
             function(c=1,b=2,a=3)   #c==1,b==2,a==3

        字典关键字传参
            是指实参为字典，将字典用　'**' 拆解后再进行关键字传参的传参方式

          说明:
              字典的键名和形参名必须一致
              字典的键名必须为字符串(标识符)
              字典的键名要在形参中存在


        函数的综合传参
            函数的传参方式在能确定形参能唯一匹配到相应实参的情况下可以任意组合
            函数的位置传参要先于关键字传参
          
          说明:
            位置传参(序列传参) 要在 关键字传参(字典关键字传参)的左侧
             # 调用时:
            1、函数的位置传参和序列传参可以混合使用，可以顺序颠倒
                myfun1(100, *[200, 300])
                myfun1(*(100, 200), 300)
                myfun1(*[100], 200, *(300,))
            2、函数位置传参和关键字传参可以混合使用
                myfun1(100, c=300,b=200) # 正确
                myfun1(c=300, b=200, 100)  # 错误
                myfun1(100, **{'c':300, 'b':200})


    函数形参的定义
        函数的缺省参数:
          语法:
              def 函数名(形参名=默认实参1, 形参名2=默认实参2, ...):
                  语句块

          说明:
              缺省参数必须自右至左依次存在，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数
            如:
               def fe(a, b=10, c):  # 错误
                     pass

        函数形参的定义方式:
                1. 位置形参
                2. 星号元组形参
                3. 命名关键字形参
                4. 双星号字典形参

          位置形参:
             语法:
                  def 函数名(形参名1, 形参名2, ...):
                       语句块

          星号元组形参
            语法:
                def 函数名(*元组形参名):
                    语句块
             作用:
                 收集多余的位置传参

          命名关键字形参:
            语法:
                def 函数名(*, 命名关键字形参):
                    语句块 
                或
                def 函数名(*args, 命名关键字形参):
                    语句块 
            作用:
                强制所有的参数都必须用关键字传参或字典关键字传参


          双星号字典形参
            语法:
                def 函数名(**字典形参名):
                   语句块
            作用:
                收集多余的关键字传参
            说明:
                字典形参名通常命名为'kwargs'

          函数的参数说明:
             位置形参，缺省参数，星号元组形参，双星号字典形参可以混合使用

          函数形参自左至右的顺序为:
                位置形参
                星号元组形参
                命名关键字形参
                双星号字典形参
            示例:
                def fx(a, b, *args, c, **kwargs):
                    pass
                fx(100, 200, 300, 400, c="C", d="D", e="E")

          函数的不定长参数:
              星号元组形参, 双星号字典形参

            说明:
                可以接收任意的位置传参和关键字传参
            示例:
                def fn(*args, **kwargs):
                    pass       
  内建函数
       python 内部的函数，不需要定义，直接调用

   eval() / exec() 函数
        把一个字符串srouce 当成一个表达式来执行，返回表达式执行的结果
        把一个字符串source 当成程序来执行
     eval 函数
        作用：把字符串当表达式来执行，返回表达式执行后的结果
        
        格式：eval(source,global=None,local=None)

        说明：source为表达式，global与local分别为字典，假设的表达式变量环境。

     　　例：1、s = '1+2+3'            2、x=100
            v = eval(s)  # v = 7      y=200
            print(v)     # 7          s='x+y'
                                      print(eval(s)) # 300

     exec 函数
         作用：把一个字符串当程序来执行,字符串可以是任意程序

         格式: exec(source,global=None,local=None)
     　 例：
          　s="x=100\ny=200\nprint('x+y',x+y)"
          　exec(s)   # 300
    dir  函数：
        dir ([对象])  返回一个字符串列表

        作用：1、如果没有参数，则返回当前作用域内所有变量的列表
             2、如果给定一个对象作为参数，则返回这个对象的所有变量的列表
                1）对于一个模块，返回这个模块的全部变量
                2）对于一个类，返回类的所有类变量，并递归
                    基类对象的所有变量
                3）对于其它对象返回所有变量，类变量和基类变量

    基本输出函数 print
        格式:  print(value, .... sep=' ', end='\n', file=sys.stdout, flush=False)
        作用:  将一系列的值以字符形式输出到标准输出设备上，默认为终端
        选项的关键字参数:
            sep: 两个值之间的分隔符， 默认为一个空格' '
            end: 输出完毕后在末尾自动追加一个字符串，默认为换行符'\n'
            file: 输出文件，默认为sys.stdout标准显示输出文件，一般是终端
            flush:　清空内存缓存区，默认不清空
        说明： 多个数据用逗号分隔开

    基本输入函数 input
        格式：  input('提示字符串') 
        作用:   从标准输入设备上读取一个字符串（末尾的换行符会被删除)
        说明:
                返回输入的字符串(仅python3)
                提示字符串可以为空
 
    高阶函数  High Order Function
    　什么是高阶函数
        满足下列条件中一个的函数即为高阶函数
          1、函数接受一个或多个函数作为参数传入
          2、函数返回一个函数

    　python  内建的高阶函数
                map , filter , sorted

    　　map 函数：
            map(function,*interables)【*表示可以有多个可迭代对象】
                返回可迭代对象，此可迭代对象用function对可迭代对象
                iterables中的每个元素作为参数计算后得到结果，再返回。
                当最短的一个可迭代对象不再提供数据时迭代结束
             后面的可迭代对象形参数对等function形参数
             (参数写函数名,map函数自己调用函数)
        例：def power2(x):
               return x**2
            for s in map(poeer2,range(1,10)):
                print(s)   #1,4,9,16,25,36,49,84,81

           函数式编程应用
		　　　print(sum(map(lambda x:x**2,range(1,10))))
		　　　print(sum(map(lambda x:x**3,range(1,10))))
		　　　print(sum(map(pow,range(1,10),range(9,0,-1))))

   　　　filter函数
       　　filter(function,iterable) 返回一个可迭代对象，此
            　　可迭代对象将对iterable获取到的数据用函数func
           　　 进行筛选；func将对iterable中的每个元素进行求值
            　　，返回False则丢弃，返回True则保留此数据。

   　　　sorted 函数
       　　　作用：将原可迭代对象的数据进行排序，生成排序后的列表
       　　　格式：sorted(iterable,key=None,reverse=False/True)
       　　　说明：
            　　 iterable 是可迭代对象，sorted函数会对其遍历
            　　　key=函数  是用来提供比较值的函数，这个值将作用
            　　#   key=abs  排序的依据(不提供默认原值)
             　　　reverse 标志用来设置是否降序排序(默认False)

    递归函数 recursion
        函数直接或间接的调用自身

      例：1、 def say_story():
                 print('从前有座灵剑山')
                 say_story()
              say_atory()      #山崩了  

          2、def fa():
                 fb()

             def fb():
                 fa()
             fa()
        说明：递归一定要控制递归的层数，当符合一定条件时要终止
                几乎所有的递归都能用while代替
        优缺点：优点是可以把问题简单化，让思路更为清晰，代码简洁
                缺点是因系统环境影响大，当递归深度太大时，
                可能会得到不可预知的结果

        递归函数调用分两个阶段
         1、递推阶段
            从原问题出发，按递归公式递推从未知到已知，最终
              到达递归终止条件
         2、回归阶段
            按递归终止条件求出结果，逆向逐步代入递归公式，
              回归原问题求解
            def myfac():
                if n ==1:
                    return
                return n*myfac(n-1)
            print(myfac(5))

  闭包 closure
            闭包是引用了此函数外部变量的函数
        闭包必须满足三个条件
         1、必须有内嵌函数
         2、内嵌函数必须引用外部函数中的变量
         3、外部函数返回值必须是内嵌函数

      例：def make_power(y):
              def fn(x):
                  return x**y
              return fn
          pow1=make_power(2)
          pow1(5)  #  25
          可以快速创建函数，Y的值因为和fn()关联，会被保存

    装饰器  
    　　作用：通常在不改变原函数的情况下，改变或添加原函数功能

   　　什么是装饰器：
        　 装饰器是一个函数，能常用来包装另一个函数或类

  函数装饰器　　(把函数作为外部变量引用的闭包)
     　是指装饰器函数，传入的是函数，返回的也是函数

    　　语法：  def 装饰器函数名１(形参):    #形参为函数
               　　def 函数２：
                        形参（）
               　　return 函数对象

            　@装饰器函数名
           　 def 函数名３(形参列表):
                　语句块
        
          　　　#函数1=装饰器函数(函数1)

        说明：执行顺序是　装饰函数１，返回函数２，被装饰函数３。
        　　　函数１　和　函数２　是嵌套关系，函数３　是调用关系　变量作用域不一样
        　　　函数１　是在定义＠的时候就执行了，函数３是传参的。
    　　 示例：
			def mydeco(fn):
			    def fx():
			       print('++++++++++++')
			       fn()
			       print('------------')
			    return fx
			@mydeco
			def myfunc():
			   print(========) 

        可以嵌套，一层一层加

    globals() / locals()函数:
          globals() 返回当前全局作用域内变量的字典
          locals()  返回当前局部作用域内变量的字典
 
    id(x)) 函数  
        　作用:  返回一个对象在内存中的地址

    type(x) 　用来返回x对应的类型

    浅拷贝  和 深拷贝
        浅拷贝 shallow copy
            浅拷贝是指在复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程
            (当深层对象被改变时，复制的对象深层对象也改变)
        示例:
                L = [3.1, 3.2]
                L1 = [1, 2, L]
                L2 = L1.copy()  # 浅拷贝
                L2[2][0] = 3.14
                print(L1)  # [1, 2, [3.14, 3.2]] 
                print(L2)  # [1, 2, [3.14, 3.2]]  当L改变时，L2也改变。

        深拷贝 deep copy
            import copy  # 导入copy模块
            L = [3.1, 3.2]
            L1 = [1, 2, L]
            L2 = copy.deepcopy(L1)  # 深拷贝
            L2[2][0] = 3.14
            print(L1)  # [1, 2, [3.1, 3.2]]  #<<--此处不变
            print(L2)  # [1, 2, [3.14, 3.2]]  

        注:
            深拷贝通常只对可变对象进行复制，不可变对象通常不会复制

        小结:
            L1 = [1, 2, [3.1, 3.2]]
            L2 = L1  # 不拷贝，创建一个变量同时绑定原对象
            L3 = L1.copy()  # 浅拷贝  等同于 L3 = L1[:]
            import copy
            L4 = copy.deepcopy(L1)  # 深拷贝

    数值对象的构造(创建)函数
        float(obj)            用字符串或数字转换为浮点数，如果不给出实参，则返回0.0
        int(x=0, base=10)     用数字或字符串转换为整数，如果不给出实参则返回0
        complex(r=0.0, i=0.0) 用数字创建一个复数
        bool(x)               用x创建一个布尔值(True/False)
        　　bool(obj) 返回假值的情况:
                None  空值
                Flase 假值
                0, 0.0, 0j  所有的数字零
                -----以下后面会讲-------
                ''   空字符串
                []   空列表
                {}   空字典
                ()   空元组
                ...

    内建数值型函数
        abs(x)     取x的绝对值
        round(number, ndigits=0) 对数值进行'四舍五入',ndigits是小数向右取整的位数，负数表示向左取整
        pow(x, y, z=None)     相当于 x ** y 或 x ** y % z

    help() 函数查看帮助
        help(函数名或对象名)
        >>> help(abs)

    python3 中常用的序列相关的函数
            序列有5种：
                str, list, tuple, bytes, bytearray

        len(x)  返回序列的长度
        max(x)  返回序列的最大值元素
        min(x)  返回序列的最小值元素
        sum(x)  返回序列中所有元素的和(元素必须是数值类型)
        any(x)  真值测试,如果列表中其中一个值为真值则返回True
        all(x)  真值测试,如果列表中所有值为真值则返回True
            示例:
                L = ['北京', 100000, "天津"]
                len(L)  # 返回结果为3
                L = [8, 3, 6, 2]
                print(max(L))  # 8
                print(min(L))  # 2
                print(sum(L))  # 19
        
        range() 函数:
            格式:
            range(stop)        从零开始，每次生成一个整数后加1操作，
                                直到stop为止(不包含stop)
            range(start, stop[, step])  从 start开始，每次生成一个整数后移动step,
                                    直到stop为止(不包含stop,且step可以是负数)
            作用:
            用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)
            说明:
            range函数调用返回的对象可用于for语句来进行依次迭代取出其中的整数
            示例：
            range(4)     # 生成 0, 1, 2, 3
            range(3, 6)  # 生成 3, 4, 5
            range(1, 10, 2)  # 生成 1, 3, 5, 7, 9
            range(5, 0, -2)  # 生成 5, 3, 1
            range(4, 0)      # 空

    字符串编码转换函数:
        ord(c)   返回一个字符的Unicode值
        chr(i)   返回i这个整数值所对应的字符

    整数转字符串函数:
        bin(i)   将整数转换为二进制字符串
        oct(i)   将整数转换为八进制字符串
        hex(i)   将整数转换为十六进制字符串

    字符串构造函数:
            str(obj='')  将对象转换为字符串
        示意:
            '123' + 456  # 出错，不合法
            str(True)  # 'True'
            str(None)  # 'None'
            str(3.14)  # '3.14'

    列表的构造(创建)函数list
            list()   生成一个空的列表，等同于 []
            list(iterable)  用可迭代对象创建一个列表
        示例:
            L = list()         # L = []
            L = list("hello")  # L = ['h', 'e', 'l', 'l', 'o']
            L = list(range(5, 10, 2))  # L = [5, 7, 9]

    元组的构造(创建)函数tuple
        tuple()   生成一个空元组，等同于()
        tuple(iterable)  用可迭代对象生成一个元组
        示例：
            t = tuple()   # 等同于 t = ()
            t = tuple(range(1, 10, 3))  # t = (1, 4, 7)
            t = tuple("ABC")  # t = ('A', 'B', 'C')
            t = tuple([1, 2, 3])  # t = (1, 2, 3)
 
    字典的构造函数dict
            dict()  生成一个字的字典 等同于 {}
            dict(iterable)  用可迭代对象初始化一个字典
            dict(**kwargs)  用关键字传参形式创建一个字典
 
    集合的构造函数 set
          set()  创建一个空的集合对象(不能用{}创建空集合)
          set(iterable)  用可迭代对象创建一个新的集合对象

    固定集合的构造函数:
          frozenset()  创建一个空的固定集合
          frozenset(iterable)  用可迭代对象创建固定集合

    字节串的构造函数 bytes
            bytes()  生成一个空的字节串，等同于b''
            bytes(整形可迭代对象)  #用可迭代对象初始化一个字节串
            bytes(整数n) 生成n个值为0的字节串
            bytes(字符串，encoding='utf-8') 用字符串的转换编码
                    生成一个字节串
    
    字节数组的构造函数 
        bytearray()  生成一个空的字节数组，等同于b''
        bytearray(整形可迭代对象)  #用可迭代对象初始化一个字节数组
        bytearray(整数n) 生成n个值为0的字节数组
        bytearray(字符串，encoding='utf-8') 用字符串的转换编码
                            生成一个字节数组


python 的作用域　　(变量才有作用域，对象没有)
       作用域也叫名字空间，是访问变量时查找变量名的范围空间

    python的四个作用域:
        作用域               英文解释          英文缩写
        局部作用域(函数内)    Local(function)         L
        外部嵌套函数作用域 Enclosing function locals  E
        函数定义所在模块(文件)作用域  Global(module)   G
        Python内建模块的作用域      Builtin(Python)   B

      变量名的查找规则
        在变量访问时，先查找本地变量，然后是包裹此函数外部的函数内部的变量，之后是全局变量，最后是内建变量
            即：
            L ----> E ----> G ----> B
            在默认的情况下，变量名赋值会创建或者改变当前作用域的变量

    global 语句
        作用:
            1. 告诉解释执行器 global 语句声明的一个或多个变量，这些变量的作用域为模块级的作用域，也称作全局变量
            2. 全局声明(global)将赋值语句操作的变量映射到模块文件内部的作用域

        语法:
            global 变量1, 变量2, ...
        
        说明:
            1. 全局变量如果要在函数内部被赋值，则必须经过全局声明（否则会被认为是创建局部变量)
            2. 全局变量在函数内部不经过声明就可以直接访问(变量已经存在并关联一个对象)
            3. 不能先声明局部变量，再用global声明为全局变量，此做法不附合规则
            4. global变量列表里的变量名不能出现在此作用域的形参列表里

    nonlocal 语句
        作用:
            告诉解释执行器，nonlocal声明的变量不是局部变量，也不是全局变量，它是外部嵌套函数内的变量

        语法:
            nonlocal 变量名1, 变量名2, ....
        
        说明:
            1. nonlocal 语句只能在被嵌套的函数内部进行使用
            2. 访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
            3. 当有两层或两层以上函数嵌套时，访问nonlocal变量只对最近的一层变量进行操作
            4. nonlocal语句的变量列表里的变量名，不能出现在此函数的参数列表中

python 程序结构与导入
        dir  函数：
            dir ([对象])  返回一个字符串列表

            作用：1、如果没有参数，则返回当前作用域内所有变量的列表
                 2、如果给定一个对象作为参数，则返回这个对象的所有
                    变量的列表
                    1）对于一个模块，返回这个模块的全部变量
                    2）对于一个类，返回类的所有类变量，并递归
                        基类对象的所有变量
                    3）对于其它对象返回所有变量，类变量和基类变量
    模块的导入语句
        inport  语句
            语法：
                inport 模块名1 [as 模块新名1]，模块名2
                        [as 模块新名2],........
            作用：将某模块整体导入到当前模块中

            用法： 模块名.属性名 
        属性就是变量，绑定函数或数据

            如：
                inport math
                print(math.factorial(5))  # 绑定阶乘函数
                print('圆周率：',math.pi) #绑定圆周率数据

            dir(obj) 函数 ， 返回模块内所有属性的字符串列表
            help(模块名)    可以查看模块相关的文档字符串

        from import 语句
            语法：from 模块名 import 模块属性名1 [as 属性新名1],
                                模块属性名2 [as 属性新名2]

             作用：将某个模块的一个或多个属性导入到当前模块的作用域

            示例：
                from math import sin
                from math import pi,e,cos
                from math import factorial as fac
                print(sin(pi/2)*fac(5))
    
        from import * 语句
            语法： from 模块名 import*
            作用：将某模块的所有属性导入到当前模块

            示例：from math import *
                print(sin(pi/2))
                print(factorial(5))
            说明：不能改名，可能发生变量名冲突（以变量名形导入）。

    函数的文档字符串
        函数内第一次未赋值给任何变量的字符串是函数的文档字符串

        语法： def 函数名(参数列表)：
               "函数的文档字符串"
               函数语句块
         示例：
            def cba():
               """这是一块文档字符串......."""
               pass
          >>>help(max)

        作用：用来描述说明函数的使用方法

    函数的 __doc__属性
    
        __doc__属性用于记录函数的文档字符串

        如：print(cab.__doc__)

  模块  Module
            模块是包含一系列数据，函数，类等组成的程序组
            模块是一个文件，模块文件名通常以.py 结尾
        作用：让一些相关的数据，函数，类等有逻辑的组织在一起
              使逻辑结更加清晰
            模块中的数据，函数和类等可提供给其他模块或程序用

      import 语句 搜索模块的路径顺序
          1、搜索内建模块 
          2、搜索程序运行时的路径(当前工作目录)
          3、搜索sys.path里添加自定义的路径
         如： import sys 
              sys.path.append("/home/tarena")
              imoprt mymod
              #可以导入/home/tarena/mymod.py这个模块

      模块化编程的优点
         1、有利于多人合作开发
         2、使代码更便于维护
         3、提高代码的复用率
         4、模块化编程有利于解决函数名和变量名冲突
             (模块内的变量的作用域为模块内全局)

        模块的加载过程
            在模块内导入时，模块的所有语句会执行
            如果一个模块已经导入，则再次导入时不会重新执行模块内的语句

        模块的重新加载
            import imp
            imp.reload(模块名)   # 修改模块后重新加载

        模块被导入和执行的过程
            1、搜索相关的路径找模块文件.py
            2、判断是否有此模块对应的.pyc文件。如果.pyc文件比.py
            文件新则直接加载.pyc文件，否则用.py文件重新生成
            .pyc文件并加载

        pyc 模块的编译
                编译                   执行
            mymod.py  ---->mymod.pyc------->python3
                    python3能看懂的16进制文件)

        模块的预置属性(系统创建的，可以直接调用的) 
            __doc__  绑定模块的文档字符串
                    模块的文档字符串是第一块没有赋值给任何变量的
                    字符串

            __file__  用来绑定模块所对应的的文件路径名(内建看不到)

            __name__  作用：1、记录模块名
                            2、用来判断是否为主模块
                    说明：当此模块为主模块时，__name__绑定
                            '__main__'
                            当此模块不是主模块运行，而是被其他模块
                            导入时，此模块名为模块文件.py前面的模块
                            名   如：mymod.py 的模块名为 mymod

        模块里的__all__列表
            
            是用来存储可导入属性的字符串列表
            作用：限制用from xxx import * 语句导入时导入部分属性，
                而不是全部属性

                __all__=['a','s','d','f']

        模块内的隐藏属性
            模块内以'_'开头的属性，在from xxx import *导入时将
            不会被导入，通常称这些属性为隐藏属性

      　模块的分类
        　　1、内置模块，在解析器内部可以直接使用(通常C写的)
        　　2、标准库模块，安装python时已安装，且可以直接使用
        　　3、第三方模块，(通常为开源，需要自己安装)
          　　　$ pip3 install xxxx
        　　4、用户自己编写的模块(也可以作为他人的第三方模块)
    自定义模块
        要求：模块文件名后缀必须为 .py 结尾
             模块文件名必须是合法的标识符
             避免名称和内建模块名冲突
          导入方式：
               import  自定义模块名
               from 自定义模块名 import 属性
               from 自定义模块名 import *
          与内建模块方式相同
        ctrl + 鼠标点击 模块或函数，可以看源码(在导入行)

    内建模块
    　　 数学模块： math
      　　　模块名 ：math
        　　　import math
        　　　from math import sin,cos,pi
        　　　from math import *

    　　 时间模块 time
		    模块名  ： time 
		    公元纪年是从公元 0000年1月1日0时开始的

            计算机元年是从1970年1月1日0时开始的,此时时间为0,
            之后每过一秒时间+1

            UTC 时间 (Coordinated Universal Time) 是从Greenwich
            时间开始计算的.
            UTC 时间不会因时区问题而产生错误

            DST 阳光节约时间(Daylight Saving Time)，又称夏令时,
            是一个经过日照时间修正后的时间

            时间元组
            时间元组是一个9个整型元素组成的,这九个元素自前
            至后依次为:
            
            四位的年(如: 1993)
            月 (1-12)
            日 (1-31)
            时 (0-23)
            分 (0-59)
            秒 (0-59)
            星期几 (0-6, 周一是 0)
            元旦开始日 (1-366)
            夏令时修正时间 (-1, 0 or 1).
            
            注：
                如果年份值小于100,则会自动转换为加上1900后的值 
        系统模块 sys
             　　运行时系统相关的信息
        　　 模块名： sys 
        
        随机模块  random
            　作用： 用于模拟或生成随机输出的模块
            函数名	           描述
            R.random()	    返回一个[0, 1) 之间的随机实数(小数)
            
            R.uniform(a,b)	  返回[a,b) 区间内的随机实数(小数)
            
            R.randrange([start,] stop[, step])	返回range(start,stop,step)
                                                中的随机数
            
            R.choice(seq)	  从序列中返回随意元素
            
            R.shuffle(seq[, random]) 随机指定序列的顺序(乱序序列）(洗牌)
            R.sample(seq,n)	         从序列中选择n个随机且不重复的元素

  包（模块包） package
            包是将模块以文件夹的组织形式进行分组管理的方法

            作用：将一系列模块进行分类管理，有利于防止名字冲突
                可以在需要时加载一个或部分模块而不是全部模块

        usr/lib/python3

        包的导入：
            同模块的导入规则基本相同
            语法：
                import 包名 [as 包别名]
                import 包名.模块名 [as 模块新名]
                import 包名.子包名.模块名[as 模块新名]
                ...........
                from 包名 import 模块名 [as 模块新名]
                from 包名.子包名 import 模块名 [as 模块新名]
                from 报名.子包名.模块名 import 属性名 [as 属性新名]
                ......
                from 包名 import *  对包与子包没作用，要与__all__结合

        __init__.py 文件
            此文件是常规包内必须存在的文件，此文件会在包被导入时
            自动调用

            作用：编写此包的内容
                在内部填写包的文档字符串
                在 __init__.py 内可以加载此包所依赖的一些其它模块

        包内的__all__列表
            作用：用来记录此包中有那些子包或模块在from import *语句
                导入时需要被导入
            说明：__all__列表只对from import * 语句起作用

                在__init__.py中加入__all__=[模块] ，from import *
                起作用

        包的相对导入
            包的相对导入是指包内模块的相互导入

            语法：from 相对路径包或模块 import 属性或模块名
                from 相对路径包或模块 import *

            相对路径：
                . 代表当前目录
                ..代表上一级目录
                ...代表上二级目录
                ....依次类推
                注：相对导入时不能超出包的外部
                    import 不能相对导入

                from ..子包 import 模块

        包在导入的时候要避免相互导入

        包的加载路径：
            1、当前工作路径
            2、sys.path 提供的路径
                模块的加载路径设置方法 
                    sys.path(“新路径”)

异常　exception
        错误是指由于逻辑或语法等导致一个程序无法正常执行的问题
        异常是程序出错误时标识的一种状态
        当异常发生时，程序不会再向下执行，而转去调用此函数的地方
        待处理此错误并恢复为正常状态
 
        作用：用作信号，通知上层调用者有错误产生需要处理

    try语句
        两种语法：
                try-except  
                try-finally

        try-except语句
            语法：
           try:
               可能触发异常的语句
           except  错误类型1 [as 变量名1]:
               异常处理语句1
           except  错误类型2 [as 变量名2]:
               异常处理语句2
           except  (错误类型3,错误类型4) [as 变量名3]:
               异常处理语句3
           except:
               异常处理语句other
           else:
               未发生异常语句
           finally:
               最终语句
        作用：
              尝试捕获异常通知，将程序由异常流程转为正常流程
              并继续执行
        说明：
              except 子句可以有一个或多个，但至少有一个。
              as  变量名绑定错误对象 ，记录错误原因。
              except:  匹配全部的错误类型
              else:   在try 语句没发生异常时执行
              finally： 不论是否异常都会执行

        try-finally 语句
            语法：
                try:
                    可能触发异常的语句
                finally:
                    最终语句
            说明：
                    finally  子句不可以省略
                    一定不存在except子句
            作用：
                1、通常用 try-finally 语句来做触发异常时必须要处理
                    的事情，无论异常是否发生，finally子句都会被执行
                2、try-finally 语句不会改变程序的状态(正常，异常)

    raise 语句
            作用：
                触发一个错误，让程序进入异常状态
                发送错误通知给调用者

            语法： raise 异常类型
                    或
                  raise 异常对象
                  或
                  raise 重新触发上一次异常
                  (放在except .. as aaa
                    raise  [aaa]        )

            报错机制 raise 触发错误，try接错误
            raise 语句会打断程序执行，返回错误

        错误构造函数 
                错误类型("错误对象")
                as 变量名=错误对象
        raise IndexError("stack error:试图从空栈中弹出数据")

    assert 语句(断言语句)
             语句：
                assert 真值表达式，错误数据(通常是字符串)
             作用：
                 当真值表达式为False时，用错误数据创建一个
                 AssertionError类型错误，并进入异常状态

            等同于： if bool(真值表达式) == False:
                         raise AssertionError(错误数据)

            可以用try语句捕获

    with 语句
        语法： with 表达式1 [as 变量1],表达式2 [as 变量2],....:
                    语句块
            with open("file.txt") as f:
                s = f.read()

        作用：
                使用对资源进行访问的场合，确保使用过程中，不算是否
            发生异常，都会执行必须的'清理'操作，并释放资源，

        如:文件使用后自动关闭，线程中锁的自动获取和释放等

        说明：with 语句并不会改变异常的状态
            能够用with进行管理的对象必须是环境管理器

    小结
            异常处理相关语句：
                try-except 语句：
                     作用:
                      捕获异常通知，将程序由异常状态转为正常状态

                try-finally 语句
                    作用：
                        执行必须要执行的语句

                raise 语句
                    作用：触发异常(抛出异常)，让程序进入异常流程

                assert 语句
                    作用：
                        根据条件来触发AssertionError类的异常
                        并进入异常流程
python 器
    函数装饰器　　(把函数作为外部变量引用的闭包)
     　是指装饰器函数，传入的是函数，返回的也是函数

    　　语法：  def 装饰器函数名１(形参):    #形参为函数
               　　def 函数２：
                        形参（）
               　　return 函数对象

            　@装饰器函数名
           　 def 函数名３(形参列表):
                　语句块
        
          　　　#函数1=装饰器函数(函数1)

        说明：执行顺序是　装饰函数１，返回函数２，被装饰函数３。
        　　　函数１　和　函数２　是嵌套关系，函数３　是调用关系　变量作用域不一样
        　　　函数１　是在定义＠的时候就执行了，函数３是传参的。

    　　 示例：
			def mydeco(fn):
			    def fx():
			       print('++++++++++++')
			       fn()
			       print('------------')
			    return fx
			@mydeco
			def myfunc():
			   print(========) 

        可以嵌套，一层一层加

    迭代器 Iterator
    　　　 能提供迭代器的对象是可迭代对象（类包含__iter__和__next__方法的对象）
        　是访问可迭代对象的工具 ,记录访问数据的次序信息，到第几个元素了
        　　　　　（用对象属性来计数，调用一次__next__方法，计数加　１　）
       　 迭代器是指用iter(obj) 函数返回的对象(实例)
        　迭代器可以用next(it) 函数获取可迭代对象的数据
    　　可迭代对象：str,list,tuple,dict,set,frozenset,bytes,bytearray.

      迭代器(高级)
        可以用next(it) 函数迭代取值的对象，就是迭代器

      迭代器协议
        迭代器协议是指对象能够使用next函数获取下一项数据，
        在没有下一项数据时触发一个StopIteration异常来终止
        迭代的约定

		 def __next__(self):
		       ....

        什么是可迭代对象
            是指能用iter(obj) 函数返回迭代器的对象(实现)

            可迭代对象的实现方法
                def __iter__(self):
                    return 迭代器


    　跌代器函数：
     　　iter(iterable) 从可迭代对象中返回一个迭代器，iterable
         　　 必须是能提供一个迭代器的对象

        next(iterator)  从迭代器iterator中获取下一个记录，
         　　　如果无法获取下一个记录，则触发StopIteration异常通知

            说明：迭代器只能往前取值，不能后退
            L=[1,2,3,4,5]
            it=iter(L)
            while 1:
                try:
                    x=next(it)
                    print(x)
                except StopIteration:
                    break
            等同于for 语句

    生成器  Generator (python2.5及之后)
        是指能够动态提供数据的可迭代对象
        生成器是在运行时生成数据，与容器类不同，它通常不会
        在内存中保存大量数据，而是现用现生成

      生成器有两种:
            1、生成器函数
            2、生成器表达式

      生成器函数：
         含有yield语句的函数是生成器函数，此函数被调用将返回
         一个生成器对象（把函数创建为可迭代类的对象了）
            yield 翻译为(产生或生成)

    yield 语句
       语法:     yield 表达式
    
       说明： yield 用于 def 函数中，目的是将此函数作用生成器
                   函数使用
             yield 用来生成数据，供迭代器的next(it)函数取值
               有 yield语句的函数不会return，只返回生成器

                def fn():
                    yield 2
                    yield 3
                    yield 5
                    yield 7
                gen=fn()    # gen 是一个生成器对象
                it=iter(gen)
                print(next(it))     # 2
                print(next(it))     # 3
                print(next(it))     # 5
                print(next(it))     # 7
                print(next(it))     # StopIteration

        生成器函数说明：
                1、生成器函数调用将返回一个生成器对象，生成器对象是
                    可迭代对象
                2、在生成器函数内调用return 语句会触发StopIteration
                    异常(即生成数据结束)
                3,只有next()调用时，生成器函数才执行，并保存执行状态．

            少占用内存，现要现生成，对于需要返回序列的函数好用


        生成器表达式
            语法：(表达式 for 变量 in 可迭代对象 [if 真值表达式])

            说明： if 子句可以省略
            作用： 用推导式形式创建一个新的生成器

        迭代工具函数
            作用：用来生成一颗个性化的可迭代对象

            函数                       说明

            zip(iter1[,iter,...]) 返回一个zip生成器对象，此对象用于
                         生成元组，元组的数据分别来自于参数中是每个可迭代
                         对象，生成元组的个数由最小的可迭代对象的大小决定

            enumerate(iterable, start=0) 返回一个enumerate生成器对象,此对象生成类型为(索引,值)的元组,默认索引从零开始,也可以用start指定

                示例:
                    numbers = [10086, 10000, 10010,95588]
                    names = ['中国移动','中国电信','中国联通']
                    for t in zip(numbers, names):
                        print(t)

                    for n, m in zip(numbers, names):
                        print(m,'的客服电话是', n)

                    d = dict(zip(numbers, names))

                    for t in zip(numbers, names, range(1000)):
                        print(t)
                
                enumerate 示例
                    names = ['中国移动', '中国电信', '中国联通']
                    for t in enumerate(names):
                    print(t)  # (1, '中国移动'), ...

    环境管理器：
        1、类内有__enter__和__exit__实例方法的类创建的实例被称
                为环境管理器
        2、能够用with进行管理的对象必须是环境管理器
        3、__enter__方法将在进入with语句时被调用，且返回由as变量
            管理的对象
        4、__exit__方法将在离开with语句时被调用，且可以用形参来
            判断离开with语句时的状态

                    class A:
                def __enter__(self):
                    print("已经进入")
                    return self
                def __exit__(self,exc_t,exc_v,exc_tb):
                    '''exc_t用来绑定异常类型
                    exc_v用来绑定异常对象
                    exc_tb用来追踪对象
                    在没有异常时三个绑定None'''
                    if exc_t is None:
                        print("正常离开")
                    else:
                        print("异常离开")
            with A() as a:
                print("这是with语句内部的语句")
                int(input("请输入整数:"))
                
文件 File
       用于数据存储的单位
       文件通常用于长期存储数据
       文件中的数据是以字节byte为单位进行顺序存储的

    文件的操作流程
       1、打开文件
       2、读/写文件
       3、关闭文件

    文件的打开函数
        open('file',mode='rt') 用于打开一个文件，返回此
            文件流对象，如果打开失败，则会触发OSError错误

            file 是文件路径名的字符串'/home/aid1808/
                                  linux/code/1.py'
            
            mode 是文件打开的模式，默认是'rt'
                ('r','w','x','a','b','t','+')

    打开模式：
       二进制：把文件看成字节数据，读写时会直接把磁盘数据
               以字节串形式返回或写入
       文本模式 ：把文件看成是字符数据，读写过程中会自动编/
                  解码(默认是'utf-8')，而且会把换行符自动
                  转换。

    文件关闭方法
        F.close()  关闭已经打开的文件，释放系统资源
                    (释放缓冲区，内核资源)

        例：f=open('文件名')  #打开文件
          f.close()         #关闭文件

    文本文件的基本操作
 
        读文件： (读取时每行行尾自带换行符，需要用S.strip()处理)
            F.readline()   # 迭代返回一行文本字符串 (调用一次换一行)
            F.readlines()  # 返回以一行文本字符串为一个元素的列表
            F.read([n])    # 返回n个字符的文本字符串  空为全读
        文件过大时要注意内存
        转义字符也会读取，占字节

        写文件：(只能以字符串写入)
            F.write(字符串)  #写入字符串到文件(不会自动添加换行符，需手动添加)
            F.writelines(字符串列表)  #将以字符串为元素的列表，以元素为行写入文件
            例：
                f=open('wenjian.txt','w')
                f.write('niu\nB')
                print(f)
                f.close()
                n=open('wenjian.txt')
                print(n.read())
                n.close()

    文本文件读写时各操作系统的换行符问题
        Linux换行符：'\n'
        Window换行符：'\r\n'
        新的Mac OS X 的换行符：'\n'

    文本文件操作说明：
        文本模式下，各操作系统的换行符在读入python内部时会自动转换为'\n'

    VS code 下面LF 可以调节换行符，让文件在不同系统同样换行。
        (LF 为\n   CRLF 为\r\n) 转换后保存文件就可以了


    文件的迭代读取
        文件流对象是可迭代对象，迭代过程将以换行符"\n"
        作为分隔符依次获取


    二进制文件操作
        操作模式字符:'b'打开
        默认文件中存储的都是以字节(bytes为单位的数据，
                                    通常有人为规定的格式)
        对二进制文件的读写需要用字节串(bytes)进行操作

    F.read()的返回类型
        对于文本模式。F.read() 返回类型为字符串str
        对于二进制模式。F.read() 返回字节串bytes

    F.tell()  返回当前文件流的绝对位置(int)
    F.seek(偏移量，whence=相对位置)
            偏移量：
                大于0的数代表向后偏移(文件尾方向)
                小于0的数代表向文件头方向偏移
            相对位置：
                0 代表文件头位置开始偏移
                1 代表从当前位置开始偏移
                2 代表从文件尾开始偏移

    F.flush() 清空内存缓冲区，把写入文件转入硬盘或即时打印。
            (U盘弹出就是这操作)
        无限循环和时间函数都可能让输出缓冲，得不到效果。


    标准输入输出文件
        sys.stdin  标准输入文件(默认为键盘)
        sys.stdout 标准输出文件(默认为屏幕终端)
        sys.stderr 标准错误输入文件(默认为屏幕终端)

        标准文件不需要打开关闭，可以直接使用
        import sys
        s = sys.stdin.readline()  #等同 input 
        print(s)
        ## input()会调用sys.stdin,关闭sys.stdin后，input()不可用

        sys.stdout.write()    #等同 print()
        ptint(*arg,sep=' ',end='\n',file=sys.stdout,flush=False)
            file=指定文件对象就能把输出打印到指定文件
            flush=True 清空缓冲区，即时打印。


                

字符编码：
        ASCII字符表:
            $ man ascii<回车>
        
        汉字编码问题
            UTF-8  一个汉字三字节
        
        汉字编码：
            国标系列：
                GB18030(二字节或四字节编码，共27533个汉字)
                    GBK(二字节编码，共21003个汉字)
                        GB2312(二字节编码，共6763个汉字)
            注：Windows常用

            国际标准：
                Unicode  <---> UTF-8 8bit 
                Unicode32    四字节
                    Unicode16    二字节
                (Linux / Mac OS X / Android 常用)

        python 的编码字符串
            'gb18030'
            'gbk'
            'gb2312'
            'utf-8'
            'ascii'

    编码注释：
            在源文件的第一行或第二行写入如下内容为编码注释
            # -*- coding:gbk -*-
            或
            # -*- coding:utf-8 -*-
        作用：
            告诉python解释执行器当前文件的编码(避免乱码)

类　type    class
        拥有相同属性和行为的对象分为一组即为一个类
        类是用来描述对象的工具，用类可以创建此类的对象(实例)
    类的基本语法
 
        类的创建语句
            class 语句

                语法：  class 类名(继承列表)：　　＃　继承列表默认　object
                            '''类的文档字符串'''
                            实例方法
                            类变量
                            类方法(@classmethod)
                            静态方法(@staticmethod)
                作用：
                    创建一个类
                    用于描述此类对象的行为和属性
                    类用于创建此类的一个或多个对象(实例)

                说明：类名必须是标识符
                    类名实质是变量，它在创建类时绑定一个类

        实例构造函数
            调用表达式：
                类名([创建传参列表])
            作用：
                创建这个类的实例对象，并返回此实例对象的引用关系

            说明：实例有自己的作用域和空间名，可以为该实例添加
                实例变量(也叫属性)
            
            例：  class Dog:
                        '''此语句用来定义一个新的类型Dog'''
                        pass
                    print(Dog)
                    dog1=Dog()
                    print(id(dog1))
                    dog2=Dog()
                    print(id(dog2))

                    list1=list()
                    print(id(list1))
                    list2=list()
                    print(id(liat2))

        实例方法(instance method)
            定义语法：
                class 类名(继承列表):
                    def 实例方法名(self,形参列表)：
                        '''方法文档字符串'''
                        语句块

            作用：用于描述一个对象的行为，让此类型的全部对象都
                拥有相同的行为

            说明：1、实例方法的实质是函数，是定义在类内的函数
                2、实例方法至少有一个形参，第一个形参绑定调用
                    这个方法的实例，一般命名为'self'

        实例方法的调用语法：
                实例.实例方法名(调用实参)
                或：
                类名.实例方法名(实例，调用实参)  【当函数用】实例必须先创建
                
                例：class Dog:
                        '''此语句用来定义一个新的类型Dog'''
                        def eat(self,food):
                            '''此方法用来描述小狗吃的行为'''
                            print('id为%d的小狗正在吃%s'%(id(self),food))
                        def sleep(self,hour):
                            print('id为%d的小狗睡了%d小时'%(id(self),hour))
                        def play(self,w):
                            print('id为%d的小狗在玩%s'%(id(self),w))
                    dog1=Dog()
                    dog2=Dog()
                    dog1.eat('骨头')
                    dog2.eat('狗粮')
                    print()
                    dog1.sleep(1)
                    dog2.sleep(2)
                    print()
                    dog1.play('球')
                    dog2.play('猫')
                    Dog.play(dog1,'球')　#当函数调用  

        实例属性：instance attribute
            每个实例都可以有自己的变量，称为实例变量(也叫属性)

            使用语法：
                    实例.属性名
            赋值规则：
                    首次赋值则创建此属性
                    再次赋值则改变此属性的绑定关系
            作用：
                记录每个对象自身的数据

            说明：可以在类里面，方法里面，外面创建属性

                class Human:
                    def set_info(self,name,age,adress='不详'):
                        '''此方法用来给人对象添加姓名，年龄，地址'''
                        self.name = name
                        self.age = age
                        self.adress = adress
                        f = open('/home/tarena/aid1808/linux/human.txt','a')
                        f.write(name+' '+str(age)+' '+adress+'\n')
                        f.close()
                    def show_info(self):
                        '''显示此人信息'''
                        print('name:',self.name,'age:',self.age,'adress:',self.adress)
                s1 = Human()
                s1.set_info('小李',22,'北京')
                s2 = Human()
                s2.set_info('小赵',23,'上海')
                s1.show_info()
                s2.show_info()

            del 语句 用于删除实例属性
                语法：
                    del 对象.实例变量

            
                del 小结：1）删除变量
                                del a,b,c
                        2）删除列表中的元素
                            del L[0]
                        3）删除字典键值对
                            del d['key']
                        4）删除对象的属性
                            del obj.attr

    初始化方法
        作用：对新创建的对象添加属性(未创建时会调用父类的初始化方法)

        格式： class 类名(继承列表):
                    def __init__(self,形参列表):
                        语句块

            说明：
                1、初始化方法名必须为'__init__' 不可改变
                2、初始化方法会在构造函数创建实例后自动调用，
                    且将实例自身通过第一个参数self传入'__init__'方法
                3、构造函数的实参将能通过__init__方法的形参列表
                    传入到'__init__'方法中
                4、初始化方法必须返回None,创建多个初始化方法只有最后一个作用

                    class car:
                        def __init__(self,c,b,m):
                            self.color = c
                            self.brand = b
                            self.model = m
                            print('初始化方法被调用')
                        def run(self,speed):
                            print(self.color,'的',self.brand,self.model,
                                    '正在以',speed,'公里／小时打速度行驶')
                    a4 = car('红色','奥迪','A4')
                    a4.run(100)

    析构方法：(和初始化对应)
        class 类名(继承列表):
            def __del__(self):
                语句块

        作用：在对象销毁释放对象占用的资源
        说明：
            析构方法会在对象销毁前被自动调用
            python语言建议不要在对象销毁时做任何事，
            因为销毁的时间难以确定(对象可能被多个变量绑定)

                class car():
                    def __init__(self,info):
                        self.info = info
                        print("汽车",info,"对象被创建")
                    def __del__(self):
                        '''这是析构方法,形参只有一个self'''
                        print("汽车",self.info,"被销毁")
                c1 = car("BYD E6")
                input("press any key continue")
                print('end')

    python 的预置属性(实例变量)
        
        __dict__属性
            此属性绑定一个存储此实例自身变量的字典
            可以操作这个字典添加修改实例的属性
                实例.__dict__['属性'] = 值

        示例：class Dog:
                    pass
                dog1 = Dog()
                print(dog1.__dict__)  #{}
                dog1,kinds = "哈士奇"
                print(dog1.__dict__) # {'kinds':'哈士奇'}

        __class__属性
            __class__属性绑定创建此实例的类

            作用： 可以借助于此属性来访问创建此实例的类或类变量
                实例.__class__ 等同于实例的类
            例：
                class Dog:
                    pass
                dog1 = Dog()
                print(dog1.__class__)
                dog2 = dog1.__class__()
                print(dog2.__class__)

    用于类的函数
        isinstance(obj,class_or_tuple) 返回对象obj是否是某个类
            的对象或者某些类的一个类对象，是返回True  否返回False
        type(obj)  返回对象的类型(类)

            示例：
                isinstance(100,int)  #Ture
                isinstance(3.14,int) #False
                isinstance(变量名，类) #Ture/False

    类变量
        类变量是类的属性，此属性属于类，不属于类的实例
        是所有实例的共有属性

        作用: 通常用来存储该类创建的对象的共有属性
        说明：
                类变量可以通过该类直接访问
                类变量可以通过类的实例直接访问(取值，赋值会成为创建实例属性)
                     实例属性与类属性同名时　优先访问实例属性
                类变量可以通过此类的对象的__class__属性间接访问

            优先访问实例变量，再访问类变量。
            __class__属性访问的是类变量，赋值的也是。
                    class Car:
                        total_count = 0
                        print(total_count)
                        total_count +=100
                        print(total_count)
                    c1 = Car()
                    print(c1.total_count)
                    Car.total_count = 5
                    print(Car.__dict__['total_count'])
                    c1.__class__.total_count = 9
                    print(c1.total_count)

    类变量与初始化方法，析构方法使用
            class Car:
                total_count = 0
                def __init__(self,info):
                    self.info = info
                    self.__class__.total_count+=1
                def __del__(self):
                    self.__class__.total_count-=1
            c1 = Car("ＢＹＤ　Ｅ６")
            c2 = Car("吉利 E7")
            print("当前有%d个汽车对象"%Car.total_count)
            del c1
            print("当前有%d个汽车对象"%Car.total_count)

    类的文档字符串
        类内第一个没有赋值给变量的字符串为文档字符串
        类的文档字符串可以用类的__doc__属性访问

    类的 __slots__列表
        语法：
            __slots__=['属性名']
        
        作用：1、限定一个类创建的实例只能有固定的实例变量(属性)
            2、不允许对象添加列表以外的实例属性
            3、防止用户因错写属性名称发生错误
        说明：
            1、__slots__属性是一个列表，列表里的值是字符串
            2、含有__slots__属性的类所创建的对象没有__dict__
                属性，即实例不用字典来存储实例属性

                class Human:
                    __slots__ = ['name','age']
                    def __init__(self,n,a):
                        self.name,self.age = n,a
                    def show_info(self):
                        print(self.name,self.age)

    类方法 @classmethod
            类方法是用于描述类的行为的方法，类方法属于类，不
            属于该类创建的实例对象
        说明：
                1、类方法需要使用@classmethod装饰器定义
                2、类方法至少有一个形参，第一个形参用于绑定类，
                    约定写为'cls'
                3、类和该类的实例都可以直接调用类方法，
                        cls绑定的是实例.__class__
                4、类方法不能访问此类创建的对象的实例属性

                    class A:
                        v = 0
                        @classmethod
                        def get_v(cls):
                            return cls.v
                        @classmethod
                        def set_v(cls,value):
                            cls.v = value
                    a = A()
                    print(a.get_v())
                    a.set_v(100)
                    print(a.get_v())
                    print(A.v)
                    

    静态方法@staticmethod
            静态方法是定义在类的内部的函数，此函数的作用域是
            类的内部
        说明：
            1、静态方法需要使用@staticmethod装饰器定义
            2、静态方法与普通函数定义相同，不需要传入
                'self'和'cls'参数
            3、静态方法只能凭借该类或类的实例调用
            4、静态方法不能访问此类创建的对象的实例属性

                    class A:
                        @staticmethod
                        def myadd(a,b):
                            return a+b

                    print(A.myadd(100,200))
                    a = A()
                    print(a.myadd(300,400))
                
    对象的属性管理函数（查，改，删）
        getattr(obj, 属性名[, default])	从一个对象得到对象的属性；
                            getattr(x, 'y') 等同于x.y; 当属性不存在时,
                            如果给出default参数,则返回default,如果没有
                            给出default 则产生一个AttributeError错误
        hasattr(obj,属性名)	用给定的name返回对象obj是否有此属性,
                            此种做法可以避免在getattr(obj, name)时引发错误
                            返回True/False
        setattr(obj,属性名, value)	给对象obj的名为name的属性设置相应的
                                值value, set(x, 'y', v) 等同于 x.y = v
        delattr(obj,属性名)	删除对象obj中的name属性,
                            delattr(x, 'y') 等同于 del x.y

    继承(inhertance) 和 派生(derived)
        继承是从已有的类中派生出新的类，新类具有原类的属性
            和行为，并能扩展新的能力
        派生类就是从一个已有类中衍生出新类，在新的类上可以添加
            新的属性和行为

        作用: 1、用继承派生机制，可以将一些共有功能加在基类
                中，实现代码的共享
            2、在不改变基类代码的基础上改变原有类的功能

        名词：   基类(base class)
                超类(super class)
                父类(father class)
                派生类(derived class)
                子类(clihd class)

        继承说明：
            python3任何类都直接或间接的继承自object类
            object是一切类的超类
    
      类的 __base__属性
            作用： 用来绑定此类的第一个基类类对象
            
           __bases__属性
            作用： 用来绑定此类的所有基类类对象，为元组

            python3中的内建内继承关系：
                >>>help(__builtins__)

    用于类的函数
        issubclass(cls,cls_or_tuple) 判断一个类是否继承自某个
                类cls或tuple中的某些类中的一个类，如果是其中一
                个类的派生类，则返回True,不是返回False

    单继承
        语法：class 类名(基类名)：
                语句块

        说明：单继承是指派生类由一个基类衍生出来
        

    覆盖；override
        什么是覆盖：
        覆盖是指在有继承关系的类中，子类中实现了于基类
        同名的方法，在子类的实例调用该方法是，实际调用的
        是子类中覆盖版本，这种现象叫做覆盖

        当覆盖发生时，优先调用自身的方法，可用super调父类的方法
    
      子类对象显示调用基类方法的方式：(不建议))
            基类名.方法名(实例，实际调用传参)

      super函数  (按当前对象的__mro__去找下一级)
            super(cls,obj)  返回cls的超类的实例(要求obj必须是
                            cls类型的实例)
                    等于obj.__class__.__class__
            super()   返回绑定超类的实例，等同于super(__class__,
                        实例方法的第一个参数)必须在方法内调用

        作用： 借助super()  返回实例间接调用父类的覆盖方法
                class A:
                    def m(self):
                        print('A.m')
                class B(A):
                    def m(self):              pass
                        print('B.m')
                class C(B):
                    def m(self):
                        print('C.m')
                c=C()
                c.m            # C.m          C.m
                super(C,c).m   #B.m           A.m
                super(B,c).m   #A.m           A.m


      显示调用基类的初始化方法：
            当子类中实现了__init__方法，基类的初始化方法并不会
                被调用，此时需要显示调用基类的初始化方法
        
            class Human:
                def __init__(self, n, a):
                    self.name = n
                    self.age = a
                    print("Human.__init__被调用")
                def show_info(self):
                    print("姓名:", self.name)
                    print("年龄:", self.age)

            class Student(Human):
                def __init__(self, n, a, s=0):
                    super(Student,self).__init__(n, a)
                    self.score = s
                    print("Student.__init__被调用")
                def show_info(self):
                    # 此处的代码自己完成
                    super().show_info()
                    print("成绩:", self.score)
            s = Student("小张", 20, 100)
            s.show_info()


    封装 enclosure
            封装是指隐藏类的实现细节，让使用者不用关心类的实现细节

            封装的目的是让使用者通过尽可能少的方法或属性来操作对象

        私有属性和方法
            python类中以双下划线('__')开头，不以双下划线结尾的标识
            符为私有成员，私有成员只能使用方法来进行访问和修改
        
          以 __ 开头的属性为私有属性
          以 __ 开头的方法为私有方法

            class A:
                def __init__(self):
                    self.__p1 = 100
                    print("self.__p1=",self.__p1)
                def __m(self):
                    '''这是私有方法，此方法只能用此类的方法来调用
                    不能在其他地方调用'''
                    print("A.__m方法被调用")
                def dowork(self):
                    '''此方法可以调用私有实例属性和方法'''
                    self.__m
            class B(A):
                '''此类示意子类不能调用父类的私有成员'''
                def test(self):
                    self.__m()  #报错
            a = A()
            print(a.__p1)  # 错误，不允许访问私有属性
            a.__m()        # 错误
            a.dowork()     # A.__m方法被调用

        
        特性属性 @property 
             实现其它语言所拥有的 getter 和 setter 功能

          作用：
                用来模拟(虚拟)一个属性
                通过@propeerty 装饰器可以对模拟的属性赋值和取值加以控制
              getter  @property        取值
              setter  @属性名.setter   赋值
                
                class Student:
                    def __init__(self, s):
                        self.__score = s  # 成绩

                    @property
                    def score(self):
                        '''getter'''
                        print("调用getter")
                        return self.__score

                    @score.setter
                    def score(self, s):
                        '''setter'''
                        print("调用setter")
                        assert 0 <= s <= 100, "成绩超出范围"
                        self.__score = s

                s1 = Student(59)
                print(s1.score)  # 取值
                # s1.score = 999999999999 #触发AssertionError
                s1.score = 80   # 赋值
                print(s1.score)


    多态 polymorphic 
        是指有继承和派生关系的类中，调用基类对象的方法，
        实际能调用子类的覆盖方法的现象叫多态

        状态： 静态(编译时确定的状态)
                动态(运行时确定的状态)

        说明： 多态调用的方法与对象相关，不与类型有关
                python全部对象都只有'动态' 没有"C++" 语言
                的"编译时状态(静态)"

            class Shape:
                def draw(self):
                    print("Shape.draw被调用")
            class Point(Shape):
                def draw(self):
                    print("Point.draw被调用")
            class Circle(Point):
                def draw(self):
                    print("Circle.draw被调用")
            def my_draw(s):
                s.draw()    #此处显示出多态中的动态
            s1 = Circle()
            s2 = Point()
            my_draw(s1)    # Circle.draw被调用
            my_draw(s2)    # Point.draw被调用

    面向对象的编程语言的特征：
        封装
        继承
        多态


    多继承 multiple inheritance          只有Python和C++有多态
        多继承是指一个子类继承自两个或两以上的父类(基类)

        语法:
                class 类名(基类名1，基类名2，....):
                    pass

        说明：一个子类同时继承多个父类，父类中的方法可以同时
                被继承下来
                如果两个父类中有同名的方法，而在子类中又没有覆盖
                此方法，则结果难以确定

                class Car:
                    def run (self,speed):
                        print("汽车以",speed,"km/h的速度行驶")
                class Plane:
                    def fly(self,height):
                        print("飞机以海拔",height,"米高度飞行")

                class PlaneCar(Car,Plane):
                    pass
                p1 = PlaneCar()
                p1.fly(10000)

            缺陷： 标示符冲突的问题
                (先执行继承列表前面的父类)

        多继承的MRO(Method Resolution Order	)问题
            
            类 __mro__ 属性
            
            作用： 
                用来记录类的方法的查找顺序

                for x in cls.__mro__:
                    print(x)

    对象的字符串函数：
        str(obj)   通过给定对象返回一个字符串(这
                    个字符串通常是给人阅读的)

        repr(obj)  返回一个符合python语法规则，且能代表
                此对象的表达式字符串，通常这个字符串一定是
                一个python表达式
        例：s = "I'm a 'Teacher'"
            s1 = str(s)
            print(s1)  #  I'm a 'Teacher'
            s2 = repr(s)
            print(s2)  #  "I'm a 'Teacher'"

    函数重写
            是在自定义的类内添加相应的方法，让自定义的类创建的
            实例能够像内建对象一样进行内建的函数操作
            (对object的方法覆盖)

        对象转字符串函数的重写方法
            repr() 函数的重写方法：
                def __repr__(self):
                    ....
            str() 函数的重写方法：
                def __str__(self):
                    ....
                
        说明：
            1、str(obj) 函数先查找obj.__str__()方法，调用此方法
                        并返回结果
            2、如果obj.__str__()方法不存在，则调用obj.__repr__()
            3、如果obj.__repr__()不存在，则调用object中的repr方法
                class MyNumber:
                    def __init__(self,value):
                        self.data = value
                    def __str__(self):
                        return "数字%d"%self.data

                    n1 = MyNumber(100)
                    s1 = str(n1)
                    s2 = repr(n1)
                    print(s1)
                    print(s2)

    内建函数的重写：
            __abs__                abs(obj)函数调用
            __len__                len(obj)函数调用
            __reversed__           reversed(obj)函数调用
            __round__              round(obj) 函数调用


        数值转换函数重写

        __complex__     complex(obj) 函数调用
        __int__         int(obj)
        __float__       float(obj)
        __bool__        bool(obj)

    运算符重载： overload
            让自定义的类生成的对象(实例)能够使用运算符进行操作
        作用：
                让程序简洁易读
                对自定义的对象将运算符赋予新的规则
        说明：
                运算符重载方法的参数的固定的含义，不建议改变运算符的原含义

        算术运算符重载方式
            方法名                     运算符和表达式        说明
            __add__(self,rhs)              self + rhs           加法
            __sub__(self,rhs)              self - rhs           减法
            __mul__(self,rhs)              self * rhs           乘法
            __truediv__(self,rhs)          self / rhs           除法
            __floordiv__(self,rhs)         self // rhs          地板除
            __mod__(self,rhs)              self % rhs           求余
            __pow__(self,rhs)              self ** rhs          幂运算
                注 ： rhs 右手边


                class MyNumber:
                    def __init__(self,value):
                        self.data = value
                    def __repr__(self):
                        return '%d'%self.data
                    def __add__(self,rhs):
                        return self.data+rhs.data
                    def __sub__(self,rhs):
                        return self.data - rhs.data
                n1 = MyNumber(100)
                n2 = MyNumber(200)
                n3 = n1 + n2
                print(n1,'+',n2,"=",n3)
                n4 = n2 - n1
                print(n2,'-',n1,"=",n4)

        反向算术运算符的重载
            当运算符左侧为内建类型，右侧为自定义类型进行算术运算时，
            会出现TypeErorr
            因无法修改内建类型的代码实现运算符重载，此时需要使用反向
            算术运算符的重载来完成重载

        反向算术运算符重载方式
            方法名                     运算符和表达式        说明
            __radd__(self,lhs)             lhs + self             加法
            __rsub__(self,lhs)             lhs - self             减法
            __rmul__(self,lhs)             lhs * self          乘法
            __rtruediv__(self,lhs)         lhs / self           除法
            __rfloordiv__(self,lhs)        lhs // self          地板除
            __rmod__(self,lhs)             lhs %  self           求余
            __rpow__(self,lhs)             lhs ** self          幂运算

            注: lhs  左手边

                    class MyList:
                        def __init__(self,n=()):
                            self.data =[x for x in n]
                            self.i = -1
                        def __repr__(self):
                            return 'MyList(%s)'%self.data
                        def __iter__(self):
                            return MyList(self)
                        def __next__(self):
                            self.i+=1
                            if self.i==len(self.data):
                                raise StopIteration
                            return self.data[i]
                        def __add__(self,other):
                            return MyList(self.data+other.data)
                        def __mul__(self,conut):
                            return MyList(self.data*conut)
                        def __rmul__(self,conut):
                            return MyList(self.data*conut)
                    L1 = MyList(range(1,4))
                    L2 = MyList([4,5,6])
                    L3 = L1 + L2
                    print(L3)
                    L4 = L2 +L1
                    print(L4)
                    L5 = L1*3
                    print(L5)
                    L6 = 3*L1
                    print(L6)

        复合赋值算术运算符的重载
            以复合赋值算术运算符 x += y 为例，此运算符会优先调用
            X.__iadd__(y)方法，如果没有__iadd__方法时会将复合赋值
            运算符拆解为 x = x +y ，然后调用 x = x.__add__(y)方法，
            如果再不存在__add__方法，则触发TypeError异常

            方法名                     运算符和表达式        说明
            __iadd__(self,rhs)           self += rhs      加法
            __isub__(self,rhs)           self -= rhs      减法
            __imul__(self,rhs)           self *= rhs      乘法
            __itruediv__(self,rhs)       self /= rhs      除法
            __ifloordiv__(self,rhs)      self //= rhs     地板除
            __imod__(self,rhs)           self %= rhs      求余
            __ipow__(self,rhs)           self **= rhs     幂运算

        比较运算符的重载
            方法名                     运算符和表达式     说明
            __lt__(self,rhs)           self <  rhs        小于
            __le__(self,rhs)           self <= rhs        小于等于
            __gt__(self,rhs)           self >  rhs        大于
            __ge__(self,rhs)           self >= rhs        大于等于
            __eq__(self,rhs)           self == rhs        等于
            __ne__(self,rhs)           self != rhs        不等于

            注：比较运算符通常返回bool值

        位运算符重载
            方法名                     运算符和表达式     说明
            __and__(self,rhs)           self &   rhs       位与
            __or__(self,rhs)            self |   rhs       位或
            __xor__(self,rhs)           self ^   rhs       位异或
            __lshift__(self,rhs)        self <<  rhs       左移
            __rsfift__(self,rhs)        self >>  rhs       右移

        反向位运算符重载：
            方法名                     运算符和表达式     说明
            __rand__(self,lhs)           lhs &   self       位与
            __ror__(self,lhs)            lhs |   self       位或
            __rxor__(self,lhs)           lhs ^   self       位异或
            __rlshift__(self,lhs)        lhs <<  self       左移
            __rrsfift__(self,lhs)        lhs >>  self       右移

        复合赋值位运算符
            方法名                     运算符和表达式     说明
            __iand__(self,rhs)           self &=   rhs       位与
            __ior__(self,rhs)            self |=   rhs       位或
            __ixor__(self,rhs)           self ^=   rhs       位异或
            __ilshift__(self,rhs)        self <<=  rhs       左移
            __irsfift__(self,rhs)        self >>=  rhs       右移

        一元运算符的重载
        方法名                   运算符和表达式         说明
        __neg__(self)                 - self             负号
        __pos__(self)                 + self             正号
        __invert(self)                ~ self             取反
                class 类名：
                    def __neg__(self):
                        L=(-x for x in self.data)
                        return 类名（L）

        in / not in 运算符重载
            方法格式：
                def __contains__(self,e):
                    return e in self.data

            # e in self   

        索引和切片运算符重载
        方法名                运算符和表达式       说明 
        __getitem__(self,i)     i=self[i]          
            复合切片：对象（::）为slice类
        __setitem__(self,i,v)   self[i]=v          赋值
        __delitem__(self,i)     del self[i]        删除


        slice（类） 构造函数：
        作用：
            用于创建一个slice切片对象，此对象存储一个切片的起始值，
            终止值，步长信息

        格式：slice(start=None,stop=None,step=None)
        slice的属性：
            s.start     
            s.stop
            s.step

