
什么是 Django
    Django 是一个开源框架，2005年发布，采用Python语言编写
    早期主要是做新闻和内容管理的
    Django本身提供了非常强大的后台管理系统

    版本: 2.1.3
    使用: 1.11.8

    官网: http://www.djangoproject.com
    中文文档 : http://djangobook.py3k.cn/2.0/

框架模式MTV
    M: Models
    T: Templates
    V: Views

Django 的安装
    查看已安装的Django版本
    import django 
    django.VERSION 查看版本

    在线安装
        sudo pip3 install django[==1.11.8指定版本，默认最新]

    下载安装包
        sudo pip3 install Django-1.11.8.tar.gz


创建Django项目
    使用 django-admin 创建Django项目

    语法： django-admin startproject 项目名

Django项目命令行
    manage.py 包含执行 django 中的各项操作的指令(子命令)    
    
    启动服务: ./manage.py runserver [0.0.0.0:port]
    创建应用: ./manage.py startapp 应用名称
        

Django项目主目录(与项目名称一致的目录)
    1. __init__.py  初始化文件，服务启动时自动运行

    2. urls.py  项目的基础url配置文件


    3. wsgi.py
        Web Server Gateway Interface
        Web  服务   网关      接口
        
    4. settings.py
        主配置文件，启动项目时自动运行的

        1 . BASE_DIR : 获取当前项目的绝对路径
        2 . DEBUG : 是否启用调试模式
            True 开发环境中使用
            False 生产环境中使用
            
        3 . ALLOWED_HOSTS 
            设置允许访问到本地项目的地址列表
            如果为空的话，表示只有本机(127.0.0.1/localhost)才能访问

            如果允许在局域网内被其他机器访问的话: 
            推荐写 ['*'],表示任何能够表示该机器的地址都能够访问到当前项目

            如果允许被其他机器访问的话 ，启动服务器时必须使用以下方式:
            ./manage.py runserver 0.0.0.0:port

        4. INSTALLED_APPS
            指定已安装的应用,如果有自定义应用的话，必须在此注册
            INSTALLED_APPS = [
                "应用名称",
            ]

        5. MIDDLEWARE
            指定中间件信息

        6. TEMPLATES
            1. BACKEND : 指定要使用的模板的引擎 
            2. DIRS : 指定模板的存放目录
                1.不写 : Django会自动的到每个应用中搜索一个叫做templates的目录来作为
                    为模板的存放目录
                2.写路径: Django会按照写的路径去搜索
            3. APP_DIRS : 是否自动搜索应用中的目录
                True : 表示要自动搜索应用中的templates目录
                False : 表示不要

        7. DATABASES
            指定数据库配置

        8. LANGUAGE_CODE
            语言设置，如果需要使用中文的话，允许更改为 zh-Hans

        9.TIME_ZONE
            指定时区,如果指定中国时区的话,允许更改为 "Asia/Shanghai"

应用
    什么是应用
        应用就是网站中的一个独立的程序模块
        在 Django 中，主目录一般不处理用户的具体请求，主要做项目的初始化配置以及请求的分发(分布式请求处理)
        具体的请求是由各个应用去处理的

    创建应用
        1.manage.py 指令创建
            ./manage.py startapp 应用名称

            ex :
                ./manage.py startapp news

        2. 在 settings.py 中进行注册
            在 INSTALLED_APPS 中追加应用名称即可
            INSTALLED_APPS = [
                "应用名称",
            ]

    应目录的文件结构
        1. migrations 文件夹
            存放数据的中间文件
            与模型相关
        2. __init__.py
            应用的初始化文件

        3. admin.py 
            应用的后台管理配置文件

        4. app.py
            应用的属性配置文件

        5. models.py
            模型的映射文件

        6. tests.py
            应用的单元测试文件

        7. views.py
            定义视图处理函数的文件



URL
    编写urls.py文件
        主路由配置文件，默认在主目录中
        包含最基本的地址映射
        作用： 通过urls.py 中定义好的地址找到对应的视图处理函数


        from django.conf.urls import url
        from django.contrib import admin   后台管理的界面
        urlpatterns = [
            url(r'^admin/',admin.site.urls),
        ]

    url()函数 的语法规范
        作用: 匹配用户的访问路径，交给对应的视图处理程序
        语法:
            from django.conf.urls import url
            urlpatterns = [
                url(regex,views,kwargs=None,name=None),
            ]

            regex : 允许是正则表达式，匹配请求的url
            views : 对应的视图处理函数
            kwargs : 字典，用来向 views 传参
            name : 为 url 起别名，在地址反向解析时使用

    通过 url 向视图传参
        http://localhost:8000/show/2018
        http://localhost:8000/show/2014
        http://localhost:8000/show/2012

        1. 使用正则表达式传参
            使用正则表达式的子组传参 - (), 一个子组就是一个参数
            多个参数的话要使用多个子组表示，并且中间使用 / 隔开

            传递的值都是字符串，需要手动转换

            #当访问路径时 /show/四个数字/ 的时候
            url(r'^show/(\d{4})/$',show1_views)
            url(r'^show/(\d{4})/(\S+?)/$',show1_views)

            在 views.py 中
            def show1_views(request,year):
                pass

        2. 通过 kwargs 参数传参
            dic = {
                "name":"wangwc",
                "age":18
            }

            url(r'^show/$',show3_views,dic)

            def show3_views(request,name,age)

    分布式的路由系统(请求地址分发)
        1.在主目录urls.py中用include函数分发路由
            from django.conf.urls import url,include
            from django.contrib import admin
            urlpatterns = [
                url(r'^',include('index.urls')),
                url(r'^admin/', admin.site.urls),
                url(r'^music/',include('music.urls')),
                url(r'^sport/',include('sport.urls')),
                url(r'^news/',include('news.urls')),
            ]

        2.在每个应用中创建 urls.py 结构参考主目录的 urls.py 


模板 (Templates)
    1. 什么是模板
      模板就是要动态呈现给用户的网页-前后端结合的网页
      Django的模板引擎是由Django自己提供的，并不是 Jinja2,
      所有Django的模板语法与Flask(Jinja2)的语法会有一些不同
    2. 模板的设置
        在 settings.by 中 有一个 TEMPLATES 变量

        1. BACKEND : 指定要使用的模板的引擎 
        2. DIRS : 指定模板的存放目录
            1.不写 : Django会自动的到每个应用中搜索一个叫做temolates的目录来作为
                    为模板的存放目录
            2.写路径: Django会按照写的路径去搜索
        3. APP_DIRS : 是否自动搜索应用中的目录
            True : 表示要自动搜索应用中的templates目录
            False : 表示不要

    3. 模板的加载方式
        1.通过 loader 对象获取模板，在通过HttpResponse进行响应
            from django.template import loader
             1. 通过 loader 加载模板
                t = loader.get_template("模板名称")
             2. 将模板渲染成字符串
                html = t.render()
             3. 将字符串通过 HttpResponse 响应给客户端
                return HttpResponse(html)

        2. 通过 render() 加载并响应模板
            from django.shortcuts import render
            return render(request,"模板名称")

    4. 模板中的语法规范
        1. 变量
            1. 作用 : 将后端的数据传递给模板进行显示
            2. 在 Django 中允许作为变量传递给模板的数据类型
                字符串，数字，列表，元组，字典，函数，对象
            
            3. 变量的语法
              1.变量必须要封装到字典中才能传递给模板
                dic = {
                    'name':'wangwc',
                    'age':30,
                    'gender':'男'
                }
                1 . 使用 loader 加载模板 
                    t = loader.get_template('xxx.html')
                    t.render(dic)
                    return HttpResponse(html)
                2. 使用 render 加载模板
                    return render(request,'xxx.html',dic)

              2. 在模板中使用变量
                    {{变量名}}  字典的键,直接写
                    Django 中复合结构不能用 []去取  只能用 . 取值     # list.3  dict.key

                    变量名为函数的函数必须要有返回值
                    类的方法调用 不要加()   class.def 即可
                 
        2. 标签
            作用: 将服务器端的功能嵌入到模板中
            
            语法:
                {% 标签内容 %}

            1. 常用标签
                 {% comment %}
                 服务器端注释,HTML<!--注释-->注释不了模板标签，只能使用comment注释,客户端不显示
                 {% endcomment %}

{% if condition1 %}
   ... display 1
{% elif condition2 %}
   ... display 2
{% else %}
   ... display 3
{% endif %}

{% if %} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，例如：

{% if athlete_list and coach_list %}
     athletes 和 coaches 变量都是可用的。
{% endif %}


{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}

{% for athlete in athlete_list %}
    <h1>{{ athlete.name }}</h1>
    <ul>
    {% for sport in athlete.sports_played %}
        <li>{{ sport }}</li>
    {% endfor %}
    </ul>
{% endfor %}



模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示：

{{ name|lower }}
{{ name }} 变量被过滤器 lower 处理后，文档大写转换文本为小写。

过滤管道可以被* 套接* ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：

{{ my_list|first|upper }}
以上实例将第一个元素并将其转化为大写。

有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：

{{ bio|truncatewords:"30" }}
这个将显示变量 bio 的前30个词。

其他过滤器：

addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。
date : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例：
{{ pub_date|date:"F j, Y" }}
length : 返回变量的长度。



 当模板系统在变量名中遇到点时，按照以下顺序尝试进行查找：

字典类型查找 （比如 foo["bar"] )5

属性查找 (比如 foo.bar )

方法调用 （比如 foo.bar() )

列表类型索引查找 (比如 foo[bar] )

系统使用找到的第一个有效类型。 这是一种短路逻辑。

句点查找可以多级深度嵌套。 例如在下面这个例子中 {{person.name.upper}} 会转换成字典类型查找
（ person['name'] ) 然后是方法调用（ upper() ):


句点也可用于访问列表索引，例如：1
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
u'Item 2 is carrots.'
不允许使用负数列表索引。 像 {{ items.-1 }} 这样的模板变量将会引发`` TemplateSyntaxError``


静态文件
    1. 不能被解释器动态解析的文件就是静态文件

    2. Django中的静态文件的处理
        (Django中必须设置静态文件相关信息之后才能使用)
        在 settings.py 中设置静态文件相关信息

        1.设置静态文件的访问路径
            STATIC_URL = "/static/"
            当访问路径为 '/static/' 时 ，就到存储目录中去查找静态文件，而不走路由解析

        2.设置静态文件的存储路径
            指定静态文件保存在服务器上的哪个文件夹中
            STATICFILES_DIRS = (os.path.join(BASE_DIR,'static'),)  元组，可以放多个文件目录
            静态文件目录的存放位置: 
            1. 在项目的根目录处创建一个 static 目录，保存静态文件
            2. 在每个应用中也可以创建一个 static 目录，用于保存静态文件
                Django会自动寻找各个static目录

        3.访问静态文件
            1. 通过静态文件访问路径去访问
                /static/images/naruto.jpg

            2. 使用 {% static %} 访问静态资源,动态获取静态文件访问路径，不写死

                {% static %} 表示的就是静态资源的访问路径
                1 . 在模板的最顶层增加
                    {% load static %}
                2 . 在使用静态资源时
                    <img src={% static "images/naruto.jpg" %}

模板的继承
    1. 在父模板中
        标识中那些内容可以在子模板中可以被重写
            {% block 块名 %}
                xxxxx
            {% endblock %}
        block 作用：
            1.在父模板中正常显示
            2.在子模板中，允许被修改
                如果不修改的话，则按照父模板的内容来显示

    2. 在子模板中
        1. 指定继承自哪个父模板
            {% extends "父模板名称.html" %}
        2. 覆盖父模板中的内容
            {% block 块名 %}
            {% endblock %}


url() 的name参数
    1. url(regex,views,kwargs,name)
        name: 为了给当前的 url 起别名，在反向解析地址时使用

    2. 反向解析
        通过 url() 的别名生成对应的访问地址
        1. 在模板上做反向解析
            1. 基本解析
                {% url '别名' %}
            2，带参数解析
                {% url '别名' '参数1' '参数2' ... %}

        2. 在视图上做反向解析
            from django.urls import reverse
            1. 基本解析
                url = reverse("别名")
                url = 就是通过别名解析出来的地址

            2，带参数解析
                url = reverse("别名",args = ("参数1"，"参数2",....))


模型- Models
    1. 根据数据库中表结构而创建出来的 class

    2. ORM
        三大特征:
        1. 数据表到编程类的映射
        2. 数据类型的映射
        3. 关系映射

    3. 创建 和 配置数据库
        1. 创建数据库
            create database webdb default charset utf8 collate utf8_general_ci;
        
        2. 在 Django 中的数据库配置
            settings.py 中 DATABASES 变量负责配置数据库的信息
            DATABASES = {
                'default': {
                     'ENGINE': 'django.db.backends.sqlite3',
                     'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
                    }
                }

            1. default : 指定一个数据库
            2. ENGINE ：指定连接到数据库的引擎
                'django.db.backends.mysql'
            3. NAME : 指定要连接的数据库的名称
                取值: 库名

            4. USER : 指定进入到数据库的用户名
                取值 : 'root'
            5. PASSWORD : 指定要连接的主机地址
                取值 : 'localhost' 或 '其他'
            
            6. PORT : 指定主机上开放的端口号
                取值 : 3306

            7. Django 中的 ORM 也依赖于 mysqldb
                在初始化项目的时候
                import pymysql
                pymysql.install_as_MySQLdb()


Models - 模型
    1. 数据库的同步操作
        1. ./manage.py makemigrations
            作用: 将每个应用下的models.py  文件生成一个数据库中间文件，并将中间文件
                保存在 makemigrations 的目录中
                1. models.py 中必须有内容
                2. 较上一次的执行必须有改动
                满足以上两个条件，则可以生成中间文件
        2. ./manage.py migrate
            作用 : 将每个应用中的 migrations 目录中的中间文件保存到数据库

    2. 编写 Models
        1.例子:
            在 index 应用中的 models.py 中
            #创建一个实体类  -Publisher 表示"出版社"
            # 1.name: 出版社名称 - varchar
            # 2.address : 出版社地址 - varchar
            # 3. city : 出版社所在城市 - varchar
            # 4. country : 出版社所在国家 - varchar
            # 5. website: 出版社网址 - varchar

        2. 创建 Models 的语法规范
            属性 = models.字段类型(字段选项)

            字段类型:映射到数据库表中的数据类型
                CharField() - varchar(允许自定义长度)
                URLField() - varchar (长度默认为200)
            字段选项 : 指定生成的字段的说明信息
                max_length = 30

            常用的字段类型(FieldTypes)
                1. BooleanField()
                    编程语言中使用 True 和 False 表示该列的值
                    数据库中使用 1 和 0 表示具体的值
                    数据库中的数据类型为 : tinyint
                
                2. CharField()
                    编程语言中使用 字符串 来表示该列的值
                    数据库中的数据类型为 : varchar
                
                3. DateField()
                    编程语言中使用 字符串 或 data 类型的数据表示该列的值
                    数据库中的 数据类型为 : date

                4. DateTimeField()
                    同上
                    数据库中的数据类型为 : DateTime

                5. DecimalField()
                    编程语言中使用数字来表示该列的值
                    数据库中使用 decimal

                    money = models.DecimalField(max_digits=7,decimal_places=2)

                6. FloatField()
                    在数据库中使用: float

                7. IntegerField()
                    数据库中使用 : int

                8. EmailField()
                    编程语言中使用 字符串 表示该列的值
                    数据库中使用 : varchar
                
                9. URLField()
                    编程语言中使用 字符串 表示该列的值
                    数据库中使用 : varchar

                10. ImageField()
                    作用: 存储图片的路径
                    数据库中使用 : varchar
					在Django模型中定义upload_to选项。

				Django模型中的ImageField和FileField的upload_to选项是必填项，其存储路径是相对于MEIDA_ROOT而来的。
				我们来看一个简单案例（如下所示)。如果你的MEDIA_ROOT是/media/文件夹，
				而你的上传文件夹upload_to=“avatar", 那么你上传的文件会自动存储到/media/avatar/文件夹。
 
def user_directory_path(instance, filename):
    ext = filename.split('.')[-1]
    filename = '{}.{}'.format(uuid.uuid4().hex[:10], ext)
    # return the whole path to the file
    return os.path.join(instance.user.id, "avatar", filename)

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    avatar = models.ImageField(upload_to=user_directory_path, verbose_name="头像")


        字段选项(Field Options):
				blank

						设置为True时，字段可以为空。设置为False时，字段是必须填写的。字符型字段CharField和TextField是用空字符串来存储空值的。

				null

					设置为True时，django用Null来存储空值。日期型、时间型和数字型字段不接受空字符串。
					所以设置IntegerField，DateTimeField型字段可以为空时，需要将blank，null均设为True。

				如果想设置BooleanField为空时可以选用NullBooleanField型字段。

				max_length

				为CharField型字段设置最大长度
            
            2. default 
                作用: 指定当前字段的默认值
            
            3. db_column
                作用 : 指定当前字段映射到数据库中列的名字，如果不指定的话则采用当前属性名为字段名
            
            4. db_index
                作用 : 为当前字段创建索引, True 则添加索引
			
			5. upload_to
				Django模型中的ImageField和FileField的upload_to选项是必填项，其存储路径是相对于MEIDA_ROOT而来的。
				我们来看一个简单案例（如下所示)。如果你的MEDIA_ROOT是/media/文件夹，
				而你的上传文件夹upload_to=“avatar", 那么你上传的文件会自动存储到/media/avatar/文件夹。
				

            6. verbose_name
                作用 : 为当前字段指定后台显示的别名

choices

由元素为2-tuples的序列(list或者tuple)作为字段的choices。2-tuple的第一个元素存储在数据库中，
第二个元素可由get_FOO_display（）方法得到。
SEX_CHOICES = (
    ('1', '男'),
    ('0', '女'),
)			
choices=SEX_CHOICES


unique

设置为True，此字段在数据库中必须是唯一的。

primary_key

如果设置为True，则此字段成为Model的主键。一般情况下，django会为Model自动添加一个叫id的IntegerField字段作为主键。

    3. 模型中的增删改查

        1. 增加数据
            1. 使用 Entry.object.create(属性=值，属性=值)
                Entry : 实体类类名，可以表示任意一个实体类
                返回值 : 将创建好的实体对象进行返回

                Book.objects.create(title='web编程基础',publicate_date="2018-1-12")

            2. 创建 Entry 对象，并通过对象.save()进行保存
                obj = Entry(属性=值，属性=值)
                obj.属性 = 值
                obj.save()
                注意 : 该方法无返回值， obj会被重新赋值

            3. 使用字典创建对象，并通过 save()进行保存
                dic = {
                    "属性" : "值",
                }
                obj = Entry(**dic)
                obj.save()
                注意 : 该方法无返回值， obj会被重新赋值

        2. 查询数据
            通过 Entry.objects 属性调用查询接口

            所有的查询接口(all(),values()...)的后面，都可以通过一个query属性来获得对应的 sql 语句


            1. 基本查询操作
                语法： all()
                用法 : Entry.objects.all()
                返回 : QuerySet[对象]  查询的结果以对象封装在列表中

            2. 查询返回指定列
                语法: values() | values("列1"，"列2")
                用法 :
                    Entry.objects.values("列1"，"列2")
                    Entry.objects.all().values("列1"，"列2")
                返回 : QuerySet[{key:value},]  会将查询出来的部分列封装到字典中，再封装到列表中

            3. 查询返回指定列 
                语法: values_list('列1','列2')
                用法: 同上
                返回值: QuerySet[(),]  会将查询出来的部分列封装到元组中，再封装到列表中

            4. 只查询一条数据
                语法 : get(条件) （条件只能是 属性=值 ）
                作用 : 查询只能返回一条数据
                返回值 : 对象
                用法 : Entry.objects.get('条件')
                    注意: 该方法只能返回一条数据，查询结果多余一条或没有就报错

            5. filter(**kwargs):　返回符合筛选条件的数据集
                语法: filter(条件)
                用法 : Entry.objects.filter('条件')
                返回值 : QuerySet[对象,]

                et:
                    1.查询 id 为1的Book的信息
                        list = Book.objects.filter(id=1)
                    2.查询 publicate_date 为 2015-10-12 的 Book
                        list = Book.objects.filter(publicate_date='2015-10-12')
                    
                    books = Book.objects.filter(id=1,publicate_date='2015-10-12')

    如果需要非等值条件查询的话，可以使用 Django提供的查询谓词来实现
            谓词	 含义	        示例	                                       等价SQL语句
        exact	  精确等于	Comment.objects.filter(id__exact=14)	                select * from Comment where id=14
        iexact    大小写不敏感的等于Comment.objects.filter(headline__iexact=’I like this’)	select * from Comment where upper(headline)=’I LIKE THIS’
        contains  模糊匹配	Comment.objects.filter(headline__contains=’good’)	 select * from Comment where headline like “%good%”
        in	      包含	Comment.objects.filter(id__in=[1,5,9])	               select * from Comment where id in (1,5,9)
        gt	      大于	Comment.objects.filter(n_visits__gt=30)	                  select * from Comment where n_visits>30
        gte	     大于等于	Comment.objects.filter(n_visits__gte=30)	          select * from COmment where n_visits>=30
        lt	      小于	 	 
        lte	    小于等于	

        startswith	以…开头	Comment.objects.filter(body_text__startswith=”Hello”)	select * from Comment where body_text like ‘Hello%’
        endswith	以…结尾	

        range	    在…范围内	start_date=datetime.date(2015,1,1)end_date=datetime.date(2015.2.1)
                Comment.objects.filter(pub_date__range=(start_date,end_date))	
                select * from Comment where pub_datebetween ‘2015-1-1’ and ‘2015-2-1’

        year	年	Comment.objects.filter(pub_date__year=2015)	
                select * from Comment where pub_datebetween ‘2015-1-1 0:0:0’ and ‘2015-12-31 23:59:59’
        month	月	 	 
        day	日	 	 
        week_day	星期几	 

        isnull	是否为空	Comment.objects.filter(pub_date__isnull=True)	
                            select * from Comment where pub_date is NULL


                Entry.objects.filter(属性__谓词=值)

            6.  exclude(**kwargs): 返回不符合筛选条件的数据集
                语法: exclude(条件)
                用法 : Entry.objects.exclude(条件)

            7. 排序查询
                语法 : order_by()
                用法 : Entry.objects.order_by("Field","-Field")
                默认是升序，如果想要降序在列名前添加 - 即可

            8. 聚合查询(不带分组)

                from django.db.models import aggregate,annotate,Avg...

                语法: aggregate()
                用法: Entry.objects.aggregate(名 = 聚合函数('列'))
                    聚合函数:
                        1. Avg():平均值
                        2. Sum()
                        3. Count()
                        4. Min()
                        5. Max()

                带分组聚合查询
                    语法: annotate()
                    用法 : Entry.objects.values('分组Field').annotate(聚合Field=聚合函数(Field)).values('分组Field'，'聚合Field')


修改
    1. 查询
        得到查询实体对象 / QuerySet

    2. 改
        通过对象的属性修改对象的值
    
    3. 保存
        实体对象.save()

      快捷方式
        QuerySet:
            QuerySet 的 update(属性=值，属性=值) 能实现批量修改+保存

删除
    1. 删除单个对象
        au = Entry.objects.get(条件)
        au.delete()
        
    2. 批量删除
        au = Entry.objects.all()
        au.delete()

5 . F查询和 Q查询

    F 查询
        1. 作用
            在执行过程中获取某列的值
        2. 语法：
            from django.db.models import F

            Entry.objects.all().update(age=F('age')+10) 查询并修改某列的值再返回

    Q 查询
        1. 作用：
            在条件中充当或(or)的实现方式

        2. 语法：
            from django.db.models import Q

            Q(条件1)|Q(条件2)

            Entry.objects.filter(Q(id=1)|Q(age=30))

6. 原生的数据库操作方法
    1. 查询
        函数 : raw(sql)
        语法 : Entry.objects.raw(sql)
        返回 : QuerySet

    2. 增删改 
        from django.db import connection
        def doSql(request):
            with connection.cursor() as cursor
                sql = "insert .. .."
                cursor.execute(sql)
            return 






2.使用后台管理 Models
	1.后台的配置
		登录地址 ：http://localhost:8000/admin

		创建后台管理员(超级用户):
			./manage.py createsuperuser
			Username : 输入用户名，默认为系统账户名
			Email Address : 电子邮件
			Password : 密码
			Password(again) : 确认密码


    2.Models 的基本管理
		1.在应用中的 admin.py 中注册要管理的实体类
			1.admin.py
				作用：注册要管理的Models类，只有注册后才能管理
			2.注册Models
				from .models import *
				admin.site.register(Entry)
		2.修改Models提升可读性
			1.重写每个实体类中的 __str__() 
				后台显示的将以 __str__ 的返回值为准
			2.为实体类中的属性们增加字段选项 - verbose_name
                name = models.CharField(max_length=30,verbose_name="姓名")
				用于修改显示的字段名
		3.通过Models类的内部类Meta定义其展现形式
			class Author(models.Model):
				... ...
				class Meta:
					1.db_table
						指定该实体类映射到的表的名称
						(该属性设置完成后需要同步回数据库)
					2.verbose_name
						定义类在 admin 中显示的名字(复数)
					3.verbose_name_plural
						定义类在 admin 中显示的名字(单数)
					4.ordering
						指定数据在后台管理中显示的排序方式
						取值为一个列表，指定排序列，默认升序，降序使用-
	3.Models 的高级管理
		1.在 admin.py 中创建高级管理类并注册
			1.定义 EntryAdmin 类 ，继承自 admin.ModelAdmin
				class AuthorAdmin(admin.ModelAdmin):
					pass
			2.注册高级管理类
				admin.site.register(Entry,EntryAdmin)
				ex:
					admin.site.register(Author,AuthorAdmin)
		2.允许在 EntryAdmin 中增加的属性
			1.list_display
                list_display = ('name','age','email')
				作用：定义在列表页上显示的字段们
				取值：由属性名组成的元组或列表
			2.list_display_links
				作用：定义在列表页上也能够链接到详情页的字段们
				取值：同上
				注意：取值必须要出现在list_display中
			3.list_editable
				作用：定义在列表页上就能够修改的字段们
				取值：同上
				注意：取值必须要出现在list_display中但不能出现在list_display_links中
			4.search_fields
				作用：定义搜索栏中允许搜索的字段值们
				取值：同上
			5.list_filter
				作用：列表页的右侧在增加过滤器实现快速筛选
				取值：同上
			6.date_hierarchy
				作用：列表页的顶部增加一个时间选择器，
				取值：属性必须是 DateField 或 DateTimeField 的列
			7.fields
				作用：在详情页面中，指定要显示哪些字段并按照什么样的顺序显示
				取值：由属性名组成的元组或列表
			8.fieldsets
				作用：在详情页面中对字段们进行分组显示
				注意：fieldset 与 fields 不能共存
				取值：
					fieldsets = (
						#分组1
						('分组名称',{
							'fields':('属性1','属性2'),
							'classes':('collapse',)
						}),
						#分组2
						()
					)

			练习：完成Publisher的高级管理功能
				1.在列表页上要显示name,address,city属性
				2.address 和 city 是可以编辑的
				3.右侧增加过滤器，允许按照city过滤筛选
				4.顶部增加一个搜索框允许按照name,website进行筛选
				5.详情页中分组显示
					1.name,address,city 为 "基本选项" 分组
					2.country,website为 "高级选项" 分组并可折叠
3.关系映射
	1.一对一映射
		1.语法
			在关联的两个类中的任何一个类都可以增加对另一个类的引用

			属性 = models.OneToOneField(Entry)

			ex:
				class Author(models.Model):
					.... ....

				class Wife(models.Model):
					.... ....
					#增加对Author的一对一引用
					author = models.OneToOneField(Author)
			
			在数据库中：
				会生成一个外键(author_id)列在 wife 表中，会引用在 author 表的主键
			在 Author 中：
				增加一个隐式属性 - wife，来表示author所对应的wife(其实就是反向引用属性)
		2.查询
			1.正向查询 ：通过 Wife 找 Author
				特点：通过自定义的关联属性查找对应实体
				wife = Wife.objects.get(id=1)
				author = wife.author
			2.反向查询 ：通过 Author 找 Wife
				特点：通过反向引用属性查找对应的实体
				author = Author.objects.get(id=1)
				wife = author.wife
			练习：
				1.通过 姓名为 "魏夫人" 的娘子信息，查找对应的author，并打印在终端上
				2.通过 姓名为 "王老师" 的作者信息，查找对应的 ，wife 并打印在终端上
	
	2.一对多映射
		1.语法
			在"多"表中增加对"一"表的外键引用
			在"多"实体中增加对"一"实体的引用
			在 "多" 实体中增加：
				属性 = models.ForeignKey(Entry)

			ex: Book(多) 和 Publisher(一)
			class Book(models.Model)
				... ...
				publisher = models.ForeignKey(Publisher)
			
			数据库中体现：
				Book 表中 增加一个外键列 publisher_id ，引用自 Publisher 表中的主键
			在实体类中的：
				1.Book 中会有一个 publisher 属性 来表示对应的 Publisher 的对象
				2.Publisher 中会有一个隐式属性 - book_set,用来表示该 publisher 对应的所有的 Book 对象的查询
                    (等同于 Book.objects)

                    publisher.book_set.filter(id=1)
                
	3.多对多映射
        1.语法
            在关联的两个类的任意一个类中，增加：
            属性 = models.ManyToManyField(Entry)

            然后在终端生成中间文件，提交数据库

            ex: Author 与 Book 可以是多对多关联关系
                1位Author可以出版多本Book
                1本Book可以由多位Author联合编写
            
                class Author(models.Model)
                    .... ....

                class Book(models.Model):
                    ... ...
                    authors = models.ManyToManyField(Author)

                shell:
                    1. ./manage.py makemigrations
         
                    2. ./manage.py migrate
                
                正向引用：
                    在 Book 中通过 authors 来表示对应的所有的书籍的查询
                反向引用：
                    在 Author 中通过 book_set 来表示对应的所有的作者们的查询

            练习：创建 Author 与 Publisher之间的关系
                1个Publisher可以有多名签约Author
                1名Author也可以有多个签约Publisher

            查询：通过 Book 查询 Author 以及 Author 查询 Book
            class Author(models.Model)
                .... ....

            class Book(models.Model):
                ... ...
                authors = models.ManyToManyField(Author)

            正向查询：通过 Book 查询 Author
                authors = book.authors.all()
            反向查询：通过 Author查询Book
                books = author.book_set.all()

        2.自定义查询对象 - objects
            Author.objects.all()
            Author.objects.filter()
            Author.objects.authors_count()

            objects 属性的类型为 models.Manager

            1.声明 EntryManager 类，继承自 models.Manager
                允许在 EntryManager中增加自定义函数

                class EntryManager(models.Manager):
                    def 函数名(self,自定义参数):
                        .... ....
                        return ...
            2.使用EntryManager对象覆盖Models类中原有的objects
                class Entry(models.Model):
                    objects = EntryManager()

            练习：
                1.在 Author 中为 objects 增加自定义方法
                    查询 Author 中年龄小于指定年龄的人的信息
                2.在 Book 中为 objects 增加自定义方法
                    查询书名中包含指定关键字的书籍的数量


2.HttpRequest - 请求
	1.什么是HttpRequest
		HttpRequest，就是对请求对象的封装，里面封装的是请求过程中的所有信息。
		在Django中HttpRequest被封装成request对象并封装到视图处理函数中，在调用视图时自动传入
	2.HttpRequest中的主要内容
		1.request.scheme : 请求协议
		2.request.body : 请求主体
		3.request.path : 请求路径
		4.request.get_full_path() : 请求完整的请求路径
		5.request.get_host() : 请求的主机地址 / 域名
		6.request.method 
		7.request.GET : 封装了get请求方式所提交的数据
		8.request.POST : 封装了post请求方式所提交的数据
		9.request.COOKIES : 封装了 cookies 中的所有数据
		10.request.META : 封装了请求的原数据
			request.META.HTTP_REFERER : 封装了请求的源地址
	3.获取请求提交的数据
		1.get 请求
			1.获取数据
				request.GET['名称']
				request.GET.get('名称')
				request.GET.getlist('名称')
			2.使用get方式提交数据的场合
				1.表单中 method 为get 的时候
				2.地址栏上拼查询字符串的时候
					http://localhost:8000/01-request/?id=1&name=xxx

				注意：
					url(r'^01-request/(\d{4})/(\d{1,})',xxx)
					http://localhost:8000/01-request/2018/10

					以上方式提交的数据不能使用request.GET来获取，因为以上的方式是 Django 标准而并非 HTTP 标准
			3.练习：
				http://localhost:8000/02-request/?year=2018&month=11&day=19
				接收请求中的数据并打印在终端上：
				年：2018
				月：11
				日：19

		2.post 请求     action 地址后面要加 /  或使用别名访问 {% url 'login' %}
			1.获取数据
				request.POST['名称']
				request.POST.get('名称')
				request.POST.getlist('名称')

			2.使用POST方式提交数据的场合

				1.使用表单提交时可以使用post


			3.CSRF verification failed (403)
				CSRF : Cross-Site Request Forgery
					    跨   站点   请求    伪装  
				
				解决方案：
					1.取消csrf的验证
						删除 settings.py中 MIDDLEWARE 中的 CsrfViewMiddleware 中间件
					2.在处理函数上增加装饰器
                        需要导入模块
						@csrf_protect
					3.可以在 表单中的 第一行增加:{% csrf_token %}
					
					4.AJXA post提交数据
					<body>

					<script>
							$.ajaxSetup({
									data: {csrfmiddlewaretoken: '{{ csrf_token }}' },
							});
					</script>


3.使用 forms 模块处理表单
	1.forms模块的作用
		通过forms模块，允许将表单与class结合(表单与实体类结合)，允许通过class生成表单
	2.使用forms模块
		1.在应用中创建 forms.py 文件
		2.导入forms模块
			from django import forms
		3.创建class，一个class对应生成一个表单
			class ClassName(forms.Form):
				pass
        4.创建属性
			一个属性对应到表单中生成一个控件

                            TOPIC_CHOICE = (
                            ('1','好评'),
                            ('2','中评'),
                            ('3','差评'),
                            )

                            #表示评论内容的表单控件的class
                            #控件1-评论标题-文本框
                            #控件2-电子邮箱-邮件框
                            #控件3-评论内容-Textarea
                            #控件4-评论级别-下拉选择框
                            #控件5-是否保存-复选框
                            class RemarkForm(forms.Form):
                            #评论标题
                            # forms.CharField() - 文本框
                            # label : 控件前的文本标签
                            subject = forms.CharField(max_length=30,label='标题')
                            #电子邮箱
                            # forms.EmailField() - Email框
                            # label : 控件前的文本标签
                            email = forms.EmailField(label='邮箱')
                            #品论内容
                            # widget=Textarea : 将当前的单行文本框变为多行文本域
                            message = forms.CharField(label='内容',widget=forms.Textarea)
                            #品论级别
                            # forms.ChoiceField() - 下拉列表框
                            # choices : 表示当前下拉列表框中的数据,取值为元组或列表
                            topic = forms.ChoiceField(label='级别',choices=TOPIC_CHOICE)
                            #是否保存-复选框
                            isSaved = forms.BooleanField(label='是否保存')

		
	3.在模板中解析 form 对象
		1.注意
			在模板中，需要：
				1.自定义 <form></form>
				2.自定义 提交按钮
		2.处理方法
			1.在 views 中创建 form 的对象并发送到模板上
				form = RemarkForm()
				return render(request,'xxx.html',locals())
			2.在模板中进行解析
				1.手动解析
					{% for field in form %}
						{{field}} :
							表示的就是form对象中的一个独立属性
							表示的也就是一个独立的控件
						{{field.label}}:
							表示的是控件中的label的值
					{% endfor %}
				2.自动解析
					1.{{form.as_p}}
						将form对象中的每个属性使用p标记包裹起来再显示
					2.{{form.as_ul}}
						将form对象中的每个属性使用li标记包裹起来，再显示
						注意：必须手动提供<ol> 或 <ul>
					3.{{form.as_table}}
						将form对象中的每个属性用tr标记包裹起来，再显示
						注意：必须手动提供<table>
                    
                        eg:
                            {% comment '手动解析' %}
                            <form action="/06-form/" method="post">
                            {% csrf_token %}
                            {% for field in form %}
                                <p>/
                                {{ field.label }}:{{ field }}
                                </p>
                            {% endfor %}
                            <p>
                                <input type="submit">
                            </p>
                            </form>
                            {% endcomment %}

                            {% comment '自动解析- {{ form.as_p }}' %}
                            <form action="/06-form/" method="post">
                            {{ form.as_p }}
                            <p>
                                <input type="submit">
                            </p>
                            </form>
                            {% endcomment %}

                            {% comment '自动解析- {{ form.as_ul }}' %}
                            <form action="/06-form/" method="post">
                            <ol>
                                {{ form.as_ul }}
                                <li>
                                <input type="submit">
                                </li>
                            </ol>
                            </form>
                            {% endcomment %}


4.通过 From 类自动获取表单数据
    1. 通过 forms.Form  的子类的构造器接收表单数据
        form = RemarkForm(request.POST)

    2. 必须使 form 通过验证之后再取值
         form.is_valid()
            返回 True: 提交的数据已通过所有验证，允许取值
            返回 False : 提交的数据未通过验证，无法取值

    3. 获取表单的数据
        通过 : form.cleaned_data 来表示提交的数据(为字典)

5. forms 模块的高级处理
    将  Models 和 Forms 结合到一起使用
        1. 在 forms.py 中创建 class ,继承自 forms.ModelForm
        2. 创建内部类 Meta , 用于关联 Model
            1. model : 指定要关联的实体类
            2. fields : 指定要从Model中取哪些属性生成控件
                1. 取值 "__all__"
                    全部属性都要生成控件
                2. 取值 为一个列表
                    将允许生成控件的属性名放在列表中
                    ["","",""]
                3. labels : 指定每个属性所关联的 label
                    取值为字典
                    labels = {
                        '属性名':"label文本"
                        ...
                    }


--------------------------------------------------------------------------------------------------------------
request对象

['COOKIES', 'FILES', 'GET', 'META', 'POST', '__class__', '__delattr__', '__dict__', '__dir__',
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__',
'__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_encoding', 
'_get_post', '_get_raw_host', '_get_scheme', '_initialize_handlers', '_load_post_and_files',
'_mark_post_parse_error', '_messages', '_post_parse_error', '_read_started', '_set_post',
'_stream', '_upload_handlers', 'body', 'build_absolute_uri', 'close', 'content_params',
'content_type', 'csrf_processing_done', 'encoding', 'environ', 'get_full_path', 'get_host',
'get_port', 'get_raw_uri', 'get_signed_cookie', 'is_ajax', 'is_secure', 'method',
'parse_file_upload', 'path', 'path_info', 'read', 'readline', 'readlines', 'resolver_match',
'scheme', 'session', 'upload_handlers', 'user', 'xreadlines']




 -----------------------------------------------------------------------------------------------------------------------   
 静态文件的配置 

settings.py

	STATIC_URL = '/static/'
	STATICFILES_DIRS=(BASE_DIR, 'static') 或		STATIC_ROOT = os.path.join(BASE_DIR, 'media').replace('\\', '/')

			#STATIC_ROOT 是在部署静态文件时(pyhton  manage  pycollectstatic)
				所有的静态文静聚合的目录,STATIC_ROOT要写成绝对地址,
				当部署项目时,在终端输入:python manage.py collectstatic
				django会把所有的static文件都复制到STATIC_ROOT文件夹下

	MEDIA_ROOT = os.path.join(BASE_DIR, 'media').replace('\\', '/')
	MEDIA_URL = '/media/'


总 urls.py
	from django.conf.urls import url, include
	from django.contrib import admin
	from sale import views


	from django.conf.urls.static import static
	from django.conf import settings

	urlpatterns = [
		url(r'^admin/', admin.site.urls),
		url(r'^$', views.index, name='index'),
		url(r'^user/', include('userinfo.urls')),
		url(r'^buy/', include('buy.urls')),
		url(r'^sale/', include('sale.urls')),

	] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


models.py
	img = models.ImageField(upload_to='img/logo', default='brandlogo.png')



------------------------------------------------------------------------------------------------

引用Django自带登录系统	
	把自定义的用户model类附加在Django自带的登录表上
	mysql> desc auth_user;
	+--------------+--------------+------+-----+---------+----------------+
	| Field              | Type             | Null | Key | Default | Extra          |
	+--------------+--------------+------+-----+---------+----------------+
	| id                   | int(11)          | NO   | PRI | NULL     | auto_increment |
	| password      | varchar(128) | NO   |     | NULL       |                           |
	| last_login      | datetime(6)   | YES  |     | NULL       |                           |	最后登录时间
	| is_superuser | tinyint(1)       | NO   |     | NULL       |              				|	超级用户
	| username     | varchar(150)  | NO   | UNI | NULL   |                			|
	| first_name    | varchar(30)     | NO   |     | NULL      |                			|
	| last_name    | varchar(30)     | NO   |     | NULL      |                			|
	| email            | varchar(254)   | NO   |     | NULL      |                			|	
	| is_staff         | tinyint(1)         | NO   |     | NULL       |                			|	后台管理员
	| is_active       | tinyint(1)        | NO   |     | NULL       |                			|	活跃状态
	| date_joined  | datetime(6)    | NO   |     | NULL      |                			|	登记时间
	+--------------+--------------+------+-----+---------+----------------+




model.py
     from django.contrib.auth.models import AbstractUser

	# Create your models here.
	SEX_CHOICES = (
		('0', '男'),
		('1', '女'),
	)

class UserInfo(AbstractUser):
    cellphone = models.CharField(max_length=11, null=False, verbose_name='手机')
    realname = models.CharField(max_length=50, null=False, verbose_name='姓名')
    uidentity = models.CharField(max_length=18, null=False, verbose_name='身份证')
    address = models.CharField(max_length=150, null=False, verbose_name='地址')
    sex = models.CharField(choices=SEX_CHOICES, default='0', max_length=10, verbose_name='性别')
   

 settings.py           当使用用户表时 让Django使用自定义的表
	AUTH_USER_MODEL = 'userinfo.Userinfo'
	#app名.类名
	
views.py	
	Django自带的登录验证和登录方法与退出登录方法，自动完成一系列动作(session等。。。)
	from django.contrib import auth
	
	验证用户，存在返回用户对象，失败Flase
	user = auth.authenticate(username=username, password=password)
		authenticate()会在User 对象上设置一个属性标识那种认证后端认证了该用户，
		且该信息在后面的登录过程中是需要的。当我们试图登陆一个从数据库中直接取出
		来不经过authenticate()的User对象会报错的！！
		from django.contrib import auth  #导入auth模块
		def login(request):
		'''
    登陆
    :param request:
    :return:
    '''
    if request.method == 'POST':
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')
        user = auth.authenticate(username =user,password=pwd)  #自动给你的user表自动校验
        if user: #登陆成功
            auth.login(request,user)  #相当于设置session
            


    return render(request,'login.html')
		
	用户登录方法
	auth.login(request, user)
	
	
	退出登录方法
	auth.logout(request)
	
	
	user对象的 is_authenticated()
			如果是真正的 User 对象，返回值恒为 True 。 用于检查用户是否已经通过了认证。
			通过认证并不意味着用户拥有任何权限，甚至也不检查该用户是否处于激活状态，
			这只是表明用户成功的通过了认证。 这个方法很重要, 在后台用request.user.is_authenticated()
			判断用户是否已经登录，如果true则可以向前台展示request.user.name

		要求：
			1  用户登陆后才能访问某些页面，

			2  如果用户没有登录就访问该页面的话直接跳到登录页面

			3  用户在跳转的登陆界面中完成登陆后，自动访问跳转到之前访问的地址

		方法1:

			直接用auth的is_authenticated()方法验证

			def my_view(request):
				if not request.user.is_authenticated():
						return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))
						
		方法2:
			根据request.user.username来验证，如果为空，则说明没有登录

			def my_view(request):
				if not request.user.username:
					return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))
					
		方法3:

			django已经为我们设计好了一个用于此种情况的装饰器：login_requierd()

			from django.contrib.auth.decorators import login_required
    
				@login_required
				def my_view(request):
 
			若用户没有登录，则会跳转到django默认的 登录URL '/accounts/login/ ' 
			(这个值可以在settings文件中通过LOGIN_URL进行修改)。并传递  当前访问url的绝对路径 
			( 登陆成功后，会重定向到该路径 )。
			修改 login.html 表单中的 action 参数
# views.py
from djanco.contrib.auth.decorators import login_required
from django.shortcuts import render_to_response
@login_required
def index(request):
# settings.py
LOGIN_URL = '/accounts/login/' # 根据你网站的实际登陆地址来设置
如果要使用 django 默认登陆地址，则可以通过在 urls.py 中添加如此配置：
# urls.py
url(r'^accounts/login/', views.login),
# login.html
<div class="container">
<form class="form-signin" action="/accounts/login/" method="post">


	创建用户

		使用 create_user 辅助函数创建用户:
		from django.contrib.auth.models import User
		user = User.objects.create_user（username='',password='',email=''）
		user.save()

实例		
def sign_up(request):
  
  state = None
  if request.method == 'POST':
  
    password = request.POST.get('password', '')
    repeat_password = request.POST.get('repeat_password', '')
    email=request.POST.get('email', '')
    username = request.POST.get('username', '')
    if User.objects.filter(username=username):
        state = 'user_exist'
    else:
        new_user = User.objects.create_user(username=username, 
								password=password,		#不用make_password，自动加密
								email=email)
        new_user.save()
  
        return redirect('/book/')
  content = {
    'state': state,
    'user': None,
  }
  return render(request, 'sign_up.html', content)　		
		
	修改密码
		用户需要修改密码的时候 首先要让他输入原来的密码 ，如果给定的字符串通过了密码检查，返回  True
		user = User.objects.get(username=request.POST.get(username))
		passwd = request.POST.get(password)
		newpasswd = request.POST.get(newpassword)
		if user.check_password(passwd):
			使用 set_password() 来修改密码
			user.set_password(password=newpasswd)
			user.save
		
		实例
		@login_required
		def set_password(request):
		user = request.user
		state = None
		if request.method == 'POST':
			old_password = request.POST.get('old_password', '')
			new_password = request.POST.get('new_password', '')
			repeat_password = request.POST.get('repeat_password', '')
			if user.check_password(old_password):
				if not new_password:
					state = 'empty'
				elif new_password != repeat_password:
					state = 'repeat_error'
				else:
					user.set_password(new_password)
					user.save()
					return redirect("/log_in/")
			else:
				state = 'password_error'
		content = {
				'user': user,
				'state': state,
				}
		return render(request, 'set_password.html', content)
	
	
 ------------------------------------------------------------------------------------               
让前端直接访问html页面,页面跳转

总urls.py
	from django.conf.urls import url
	from django.contrib import admin
	from ccode import viewUtil
	
	
	from django.views.generic import TemplateView
	
	urlpatterns = [
		url(r'^admin/', admin.site.urls),
		url(r'verifycode',viewUtil.verifycode),
		url(r'^$',TemplateView.as_view(template_name='code.html'),name="index"),
	]

    
 ------------------------------------------------------------------------------------------------------------
Django的密码加密工具 

	from django.contrib.auth.hashers import make_password, check_password
	
	#加密
	auth_check = 'MarcelArhut' #自定义
	new_user.password = make_password(request.POST.get('userpwd'), auth_check, 'pbkdf2_sha1')
	
	#对比(明文，密文),一致返回ture，不一致返回Flase
	check_password(request.POST.get('pwd'),user.password)
	