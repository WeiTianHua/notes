
正则表达式  regex

动机   
    1.文本处理已经成为计算机常见工作之一
    2.对文本内容的搜索，定位，提取逻辑比较复杂的工作
    3.为了快速方便的解决上述问题，产生了正则表达式技术

定义：
    即文本的高级匹配模式，提供搜索，替换等功能。其本质是
    一系列由字符和特殊符号组成的字符串，这个字符串即正则表达式

匹配原理：由普通字符和特殊符号构成，通过描述字符的重复，位置，
        种类等行为达到匹配某一类字符串的目的

目标：1、熟练掌握正则表达式符号
     2、读懂常见的正则表达式
     3、编写基本的搜索提取功能正则
     4、能够熟练使用re模块操作正则表达式

正则表达式特点
    1、方便文本处理
    2、支持语言众多
    3、使用灵活变化多样

python --> re模块
    re.findall(pattern,string)
    功能 ：提取所有的正则匹配内容
    参数 ：pattern  正则表达式
          string    目标字符串
    返回值：列表，所有提取到的内容


元字符的使用

一、普通字符  (字母，数字，_ , 汉字)
    元字符 : a B c
    匹配规则：每个字符匹配到对应字符(组合一起是整体匹配)，能汉字匹配，空格算字符  'a'

二、或
    元字符：|
    匹配规则 ：匹配 | 两侧任意一个正则表达式  'str1|str2'
    *python 中重叠的部分不显示后匹配的

三、匹配单个字符
    元字符： .
    匹配规则： 匹配除换行外的任意一个字符 '.str'  'st.r'  'str..str'

四、匹配字符串开始位置
    元字符： ^
    匹配规则：匹配目标字符串的开始位置  '^str'

五、匹配字符串的结束位置
    元字符： $
    匹配规则：匹配字符串的结束位置 'str$'

六、匹配重复
    元字符： *
    匹配规则：匹配前面的字符重复0次或多次  'fo*' f必须有，o可以有0个或多个。  

七、匹配重复
    元字符： +
    匹配规则：匹配前面的字符出现1次或多次  'fo+' f要有，o有一个或以上

八、匹配重复
    元字符： ？
    匹配规则：匹配前面的字符出现0次或1次   'fo?' --> f  fo 

九、匹配重复
    元字符： {n}
    匹配规则：匹配重复指定的次数  'fo{3}'  -->  fooo

十、匹配重复
    元字符： {m,n}
    匹配规则：匹配前面的字符出现 m--n次 'fo{2,4}' -->foo,fooo,foooo
                优先显示n次的

十一、匹配字符集
    元字符： [字符集]   #in [str]
    匹配规则：匹配字符集中任意一个字符  [abc] -->a b c 只能一个
        [a-z],[A-Z],[0-9],[a-zA-Z],[_#%a-z0-9]

十二、匹配非字符集
    元字符： [^字符集]  #not in[str]
    匹配规则：匹配除了字符集中的任意一个字符  [^aa789]

十三、匹配任意(非)数字
    元字符： \d   \D
    匹配规则： '\d'  匹配任意数字字符   '[0-9]'
              '\D'  匹配任意非数字字符  '[^0-9]'

十四、匹配任意(非)普通字符
    元字符： \w    \W
    匹配规则： \w  匹配任意普通字符   [_0-9a-zA-Z] 也能匹配汉字
              \W  匹配任意非普通字符
        
十五、匹配(非)空字符
    元字符： \s  \S
    匹配规则： \s  匹配任意空字符   [\r\n\t\v\f\'']
              \S  匹配任意非空字符
        
十六、匹配字符串位置
    元字符： \A    \Z
    匹配规则： \A  匹配字符串开头位置  ^
              \Z  匹配字符串结尾位置  $

    *当正则表达式前有^最后有$时，那么这个正则表达式一定是要匹配目标字符串的全部
        内容，否则就什么都不匹配。

十七、匹配单词边界  (普通字符和非普通字符的交界)
    元字符： \b   \B
    匹配规则： \b 匹配单词边界位置  
              \B 匹配非单词边界位置

正则表达式转义
    在正则表达式中  如果需要匹配特殊符号，需要加 \ 作为转义
    e.g  匹配 .   需要使用 \.

    python          正则            目标字符串

    '\\$\\d+'      \$\d+               $10

    *raw 字符串，是不对字符串内容进行转义处理
        '\\$\\d+'   --->    r'\$\d+'

匹配 . * ？ ^ $ 等元字符需要用转义或 []括起来
    需要使用\.来匹配一个小数点
    当然如果是在[.]里面的话 是不需要加\的

    空字符可以用\s表示 如 :  ([.]|[*]|\s|[?])


贪婪 和 非贪婪

    贪婪模式 ： 正则表达式的重复匹配默认总是尽可能的向后匹配更多内容
        *   +   ?    {m,n}

    非贪婪模式(懒惰模式)： 尽可能少的匹配，取最少值。  贪婪后面加问号
        *?   +?    ??    {m,n}?

        In [106]: re.findall(r"ab+?","abbbbbbbb")
        Out[106]: ['ab']

        In [107]: re.findall(r"ab??","abbbbbbbb")
        Out[107]: ['a']

正则表达式分组
    使用()可以为正则表达式建立内部分组，子组为正则表达式的一部分，
    可以看作一个内部整体

    * 有子组的正则表达式任然是整体去匹配内容，子组需在整体能够匹配到
      内容的前提下发挥作用

    子组的作用：
        1.作为内部整体可以改变某些元字符的行为

            re.search(r"(ab)+\d+","ababab1234").group()
            'ababab1234'

            re.search(r"\w+@\w+\.(com|cn)","abc@123.com").group()
            'abc@123.com'

        2. 子组在某些操作中可以单独提取出匹配内容

            re.search(r"(https|http|ftp)://\S+","https://www.baidu.com").group(1)
            Out[121]: 'https'

    子组使用注意事项
        * 一个正则表达式中可以有多个子组
        * 子组一般由外到内，由左到右称之为第一，第二 ，第三....子组
                ((ad)aa)ddd(sdf)ddf
        * 子组不能重叠，嵌套也不宜很多  
                a(df(as)df)afffff
    
捕获组 和 非捕获组
    格式 ： (?P<name>pattern)    大写的P
    e.g.
        re.search(r"(?P<dog>ab)cdef",'abcdefghti').group('dog')
        Out[130]: 'ab'

        作用 ： 名字可以表达一定含义，可以通过组名更方便获取某组内容

正则表达式设计原则
    1. 正确性 ，能正确匹配到目标内容
    2. 排他性 ，除了要匹配的内容，尽可能不会匹配与到其他内容
    3. 全面性 ，需要对目标字串的各种情况考虑全面，做到不遗漏

re模块

    regex = re.compile(pattern,flags = 0)
    功能 ： 生成正则表达式对象
    参数 ： pattern  正则表达式
            flags   功能标志位，丰富正则表达式的匹配功能
    返回值 : 返回正则表达式对象

    re.findall(pattern,string,flags=0)
    功能 ：从目标字符串查找正则匹配内容
    参数 ： pattern  正则表达式
            string  目标字符串
            flags   标志位
    返回值 ： 返回匹配到的内容列表
        如果正则有子组则只返回子组对应内容，多个子组以[(1),(2)..]返回

    regex.findall(string,pos=None,endpos=None)
    功能 ：从目标字符串查找正则匹配内容
    参数 ： string  目标字符串
            pos     匹配目标的起始位置
            endpos  匹配目标的终止位置
    返回值 ： 返回匹配到的内容列表
        如果正则有子组则只返回子组对应内容，多个子组以[(1),(2)..]返回

    re.split(pattern,string,flags = 0)
    功能：根据正则匹配内容切割字符串
    参数： pattern  string  flags
    返回值： 返回列表，列表中为切割掉正则之后的内容

    re.sub(pattern,replaceStr,string,count=0,flags=0)
    功能： 替换正则匹配到的内容
    参数：  pattern
            replaceStr ： 用作替换的内容
            string 
            count        最多替换几处 默认全部替换
            flags
    返回值 ： 返回替换后的字符串

    re.subn(pattern,replaceStr,string,count=0,flags=0)
    功能： 替换正则匹配到的内容
    参数： pattern
        replaceStr ： 用作替换的内容
        string 
        count   最多替换几处 默认全部替换
        flags
    返回值 ： 返回一个元组，为实际(替换后的字符串,替换了几处)


    re.finditer(pattern,string,flags=0)
    功能： 使用正则表达式匹配目标字符串
    参数： pattern  string flags
    返回值： 返回一个可迭代对象，
            迭代到的内容是一个match对象，位置span=(:)
            可用group()方法取值

    re.fullmatch(pattern,string,flags=0)
    功能： 完全匹配目标字符串，相当于在pattern加了 ^和$
    参数： pattern,string,flags
    返回值：返回匹配到的match对象
            如果没匹配成功返回None

    re.match(pattern,string,flags=0)
    功能： 匹配目标字符串开头位置,相当于在pattern加了 ^
    参数： pattern,string,flags
    返回值：返回匹配到的match对象
            如果没匹配成功返回None


    re.search(pattern,string,flags)
    功能： 正则表达式匹配目标字符串，只匹配第一处
    参数： pattern,string,flags
    返回值：返回匹配到的match对象
            如果没匹配成功返回None

    compile生成对象regex的属性：

        pattern    ： 属性值为正则表达式
        flags      ： 表示标志位常量值
        groups     ： 正则表达式有多少子组，没有为 0
        groupindex ： 捕获组形成组名和序列号的字典，
                      组名为键，第几组为值
                      要是捕获组才有效，不然返回{}


match object 方法和属性

属性变量
    pos         匹配目标字符串的开始位置
    endpos      匹配目标字符串的结束位置
    re          正则表达式
    string      目标字符串
    lastgroup   最后一组的组名
    lastindex   最后一组是第几组

属性方法
    span()      匹配到的内容在字符串中的起止位置
    start()     匹配到的内容在字符串中的开始位置
    end()       匹配到的内容在字符串中的结束位置

    group()
        功能: 获取match对象获取到的内容
        参数: 默认为 0 表示获取整个正则匹配到的内容
             如果为序列号或者子组名，则表示获取某个子组对应的内容
        返回值: 返回获取到的内容

    groupdict()     获取捕获组字典，组名作为键，对应内容作为值
    groups()        获取多个子组值的集合，返回元组


flags  参数的使用
    作用 : 辅助正则表达式，丰富匹配效果
        同时使用多个标志位   flags = re.I|re.M
          
    I == IGNORECASE  匹配时忽略字母大小写
    S == DOTALL      作用于元字符 .    使 . 可以匹配换行
    M == MULTILLINE  作用于 ^  $  使其匹配每一行的开头和结尾
    X == VERBOSE     可以给正则表达式添加注释